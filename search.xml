<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文本分类模型SOTA</title>
      <link href="/2022/10/10/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8BSOTA/"/>
      <url>/2022/10/10/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8BSOTA/</url>
      
        <content type="html"><![CDATA[<p>本文将分 3 期进行连载，共介绍 <strong>20 个</strong>在<strong>文本分类</strong>任务上曾取得 SOTA 的经典模型。</p><ul><li>第 1 期：RAE、DAN、TextRCNN、Multi-task、DeepMoji、RNN-Capsule</li><li>第 2 期：TextCNN、dcnn、XML-CNN、textCapsule、Bao et al.、AttentionXML</li><li>第 3 期：ELMo、GPT、BERT、ALBERT、X-Transformer、LightXML、TextGCN、TensorGCN</li></ul><p>文本分类是自然语言处理中最基本、最经典的任务，大部分自然语言处理任务都可以看作是分类任务。<br>与数字、图像不同，对文本的处理强调精细化的处理能力。传统的文本分类方法一般需要对输入模型的文本数据进行预处理，此外还需要通过人工标注的方法来获得良好的样本特征，然后使用经典的机器学习算法对其进行分类。类似的方法包括 NaiveBayes（NB）、K 近邻（KNN）、支持向量机 SVM 等。特征提取的水平对文本分类效果的影响甚至高于图像分类，而文本分类中的特征工程往往非常耗时且计算成本高。2010 年后，文本分类的方法逐渐过渡到深度学习模型。应用于文本分类的深度学习通过学习一系列的非线性变换模式将特征工程直接映射到输出，从而将特征工程集成到模型拟合过程中，一经应用就获得了巨大的成功。</p><p><strong>与图像分类模型不同，文本分类模型一般不会采用堆叠模块、修改深度模型结构等方式去改进，更多则是通过引入其它技术手段改进模型效果，例如引入注意力机制、预训练、图神经网络、胶囊网络等</strong>。所以在介绍经典文本分类模型时，更多的是介绍为了解决文本分类中的哪一类具体问题，针对性地引入了哪些专门的技术 trick，以及这些引入的 trick 是如何与原有的经典架构融合的。</p><p>此外，NLP 领域中大量工作都聚焦于前端的词、语句、文本的处理或语义理解，目的是为下游的各类任务服务。</p><p><strong>文本分类模型以 BERT 的出现明显呈现出两个不同的发展阶段，BERT 提出后（2019 年之后），单纯基于 RNN、CNN 改进的且效果比较突出的方法就比较少了。</strong></p><h1 id="一、-RNN"><a href="#一、-RNN" class="headerlink" title="一、 RNN"></a>一、 RNN</h1><p>递归神经网络（Recurrent Neural Network，RNN）被广泛用于通过递归计算捕捉长距离的依赖性。RNN 语言模型学习历史信息，考虑到适合文本分类任务的所有单词之间的位置信息。首先，每个输入词都用一个特定的向量表示，使用词嵌入技术。然后，嵌入的单词向量被逐一送入RNN 单元。RNN 单元的输出与输入向量的维度相同，并被送入下一个隐藏层。RNN 在模型的不同部分共享参数，每个输入词的权重相同。最后，输入文本的标签可以由隐藏层的最后一个输出来预测。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665385743110-8ef7501f-acce-46a7-bda5-05afece7aa76.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6e277e9c&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=1028&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u583778e5-06cd-4b25-8216-a9737ae7c40&title="><br>RNN 架构</p><h2 id="1、TextRCNN"><a href="#1、TextRCNN" class="headerlink" title="1、TextRCNN"></a>1、TextRCNN</h2><p>TextRCNN 相关论文首次发表在 AAAI 2015 中。在 TextCNN 网络中，网络结构采用“卷积层+池化层”的形式，卷积层用于提取 n-gram 类型的特征，在 RCNN（循环卷积神经网络）中，卷积层的特征提取的功能被 RNN 替代，即通过 RNN 取代 TextCNN的特征提取。RNN 的优点是能够更好地捕捉上下文信息，有利于捕获长文本的语义。因此整体结构变为了 RNN+池化层，所以叫 RCNN。</p><p>TextRCNN 在词嵌入的基础上加上了上下文环境作为新的词嵌入表示。左侧和右侧的context 是通过前向和后向两层 RNN 的中间层输出得到的。这些中间层的输出和原始的词嵌入拼接形成新的词嵌入 y，然后送入池化层。下图是 TextRCNN 模型框架，输入是一个文本 D，可以看成是由一系列单词（W_1, W_2,…）组成的。输出是一个概率分布，最大的位置对应文章属于的类别 K。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665385799336-b81e76eb-bfb0-469c-a9f7-56f9d812cc66.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf2937d25&margin=%5Bobject%20Object%5D&originHeight=442&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucba3e876-e3a6-4a7d-8229-82ff8bafe9e&title="><br>图7. 递归卷积神经网络的结构。该图是 “A sunset stroll along the South Bank affords an array of stunning vantage points “这句话的部分例子，下标表示原句中相应的词的位置<br>RCNN 整体的模型构建流程如下：1）利用前向和后向 RNN 得到每个词的前向和后向上下文的表示，词的表示就变成词向量和前向后向上下文向量 concat 起来的形式了。2）将拼接后的向量非线性映射到低维。3）向量中的每个位置的值都取所有时序上的最大值，得到最终的特征向量。4）softmax 分类得到最终的评分向量。使用随机梯度下降来对参数进行更新。</p><table><thead><tr><th>TextRCNN</th><th><a href="https://sota.jiqizhixin.com/models/models/a5a82cbe-98b7-4f3d-87ae-f9fd59caa55e">https://sota.jiqizhixin.com/models/models/a5a82cbe-98b7-4f3d-87ae-f9fd59caa55e</a></th></tr></thead></table><h3 id="2、RNN-Capsule"><a href="#2、RNN-Capsule" class="headerlink" title="2、RNN-Capsule"></a>2、RNN-Capsule</h3><p>RNN-Capsule 是胶囊方法在文本分类中的应用，相关论文发表在 EMNLP 2018 中。胶囊网络（Capsule Network）用神经元向量代替传统神经网络的单个神经元节点，以 Dynamic Routing 的方式去训练这种全新的神经网络，从而提升模型效率及文本表达能力。</p><p>该模型首先利用标准的卷积网络，通过多个卷积滤波器提取句子的局部语义表征。然后将 CNN 的标量输出替换为向量输出胶囊，从而构建 Primary Capsule 层。接着输入到作者提出的改进的动态路由（共享机制的动态路由和非共享机制的动态路由），得到卷积胶囊层。最后将卷积胶囊层的胶囊压平，送入到全连接胶囊层，每个胶囊表示属于每个类别的概率。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665386285988-19f40398-a239-40ee-9d1f-051485919f34.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uac833f15&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubf32552e-97f7-4c47-af5b-b2d95123d69&title=">图10. 用于文本分类的胶囊网络的结构。动态路由的过程显示在底部</p><p>在路由过程中，许多胶囊属于背景胶囊，即这些胶囊与最终的类别胶囊无关，比如文本里的停用词、类别无关词等等。作者提出了三种策略以减少背景或者噪音胶囊对网络的影响：</p><ol><li>Orphan 类别：在胶囊网络的最后一层引入 Orphan 类别，它可以捕捉一些背景知识，比如停用词。在文本任务中停用词比较一致，比如谓词和代词等，所以引入Orphan 类别的效果较好。</li><li>Leaky-Softmax：在中间的连续卷积层引入去噪机制。对比 Orphan 类别，Leaky-Softmax 是一种轻量的去噪方法，它不需要额外的参数和计算量。</li><li>路由参数修正：传统的路由参数，通常用均与分布进行初始化，忽略了下层胶囊的概率。相反，作者把下层胶囊的概率当成路由参数的先验，改进路由过程。</li></ol><p>为了提升文本性能，作者引入了两种网络结构，具体如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665386285957-0aa2eef8-325a-44b7-aedb-90735ecb0e5f.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0795155&margin=%5Bobject%20Object%5D&originHeight=991&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0aace264-d684-47ff-b7e8-8544d4733c6&title="></p><p>图11. 两种胶囊网络架构</p><p>Capsule-A 从嵌入层开始，将语料库中的每个词转化为 300 维（V &#x3D; 300）的词向量，然后是一个具有 32 个滤波器（B &#x3D; 32）、步长为 1 的 ReLU 非线性的 3-gram（K1 &#x3D; 3）卷积层。所有其他层都是胶囊层，从具有 32 个滤波器（C&#x3D;32）的 B×d 初级胶囊层开始，然后是具有 16 个滤波器（D&#x3D;16）的 3×C×d×d（K2&#x3D;3）卷积胶囊层和一个全连接的胶囊层，依次进行。每个胶囊都有 16 维（d&#x3D;16）的实例化参数，其长度（规范）可以描述胶囊存在的概率。胶囊层由转换矩阵连接，每个连接也要乘以路由系数，该系数由路由协议机制动态计算得出。</p><p>Capsule-B 的基本结构与 Capsule-A 相似，只是在 N-gram 卷积层中采用了三个平行网络，过滤窗口（N）为 3、4、5（见图 11）。全连接的胶囊层的最终输出被送入平均池以产生最终结果。通过这种方式，Capsule-B 可以学习到更有意义和更全面的文本表述。</p><table><thead><tr><th>RNN-Capsule</th><th><a href="https://sota.jiqizhixin.com/models/models/f8cd1ed1-5ebe-42bf-8672-a1d2d9c1c97f">https://sota.jiqizhixin.com/models/models/f8cd1ed1-5ebe-42bf-8672-a1d2d9c1c97f</a></th></tr></thead></table><h1 id="二、CNN"><a href="#二、CNN" class="headerlink" title="二、CNN"></a>二、CNN</h1><p>卷积神经网络（CNN）最初用于图像分类，其卷积滤波器可以提取图片的特征。与RNN不同的是，CNN可以同时将不同内核定义的卷积应用于一个序列的多个块中。对于文本分类，文本需要被表示为一个类似于图像表示的向量，并且文本特征可以从多个角度进行过滤，如图1所示。首先，输入文本的词向量被拼接成一个矩阵。然后，该矩阵被送入卷积层，该层包含不同维度的多个过滤器。最后，卷积层的结果通过集合层，并将集合结果连接起来，得到文本的最终向量表示。类别由最终的向量来预测。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665364905575-01d93bf0-e656-49ac-aa9d-8321e367cc7a.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud052d593&margin=%5Bobject%20Object%5D&originHeight=783&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u75e85d7b-04c4-47db-9fcc-554c3c59c94&title="></p><h2 id="1、Text-CNN"><a href="#1、Text-CNN" class="headerlink" title="1、Text CNN"></a>1、Text CNN</h2><p>TextCNN是最经典的应用于NLP的CNN，论文发表在EMNLP 2014中。它可以通过一层卷积更好地确定最大集合层中的判别性短语，并通过保持词向量的静态来学习除词向量以外的超参数。</p><p>TextCNN就是简单CNN的应用，因此结构简单，效果还很好。输入数据首先通过一个嵌入层，得到输入语句的嵌入表示，然后通过一个卷积层提取语句的特征，最后通过一个全连接层得到最终的输出。模型架构如图2。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665365011892-d45b5c59-a651-4c64-9254-9b7fe1df0b1c.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc2f36568&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u08a0a2f9-e292-45c5-9d1c-3029e6bc046&title="><br>1）嵌入层。主要作用是将输入的自然语言编码成分布式表征，方法类似于word2vec。可以使用预训练好的词向量，也可以直接在训练TextCNN的过程中训练出一套词向量。如果使用预训练好的词向量，又分为static方法和no-static方法，前者是指在训练TextCNN过程中不再调节词向量的参数，后者在训练过程中调节词向量的参数。<br>2）卷积层。主要是通过卷积，提取不同的n-gram特征。输入的语句或者文本，通过嵌入层后转变成一个二维矩阵。假设文本的长度为|T|，词向量的大小为|d|，则该二维矩阵的大小为|T|X|d|。卷积工作就是对这一个|T|X|d|的二维矩阵进行的。<br>3）最大池化层。对卷积后得到的若干一维向量取最大值，然后拼接起来作为本层的输出值。如果卷积核的size&#x3D;2，3，4，5，每个size有128个kernel，则经过卷积层后会得到4X128个一维的向量，再经过最大池化之后，会得到4X128个scalar值，拼接在一块，得到最终的结构512X1的向量。最大池化层的意义在于对卷积提取的n-gram特征，提取激活程度最大的特征。<br>4）全连接层。在最大池化层后再拼接一层，作为输出结果。实际中为了提高网络的学习能力，可以拼接多个全连接层。</p><p>| ### TextCNN</p><p> | <a href="https://sota.jiqizhixin.com/implements/4f2dcdb3-9422-46e6-883e-c2af64f01081">https://sota.jiqizhixin.com/implements/4f2dcdb3-9422-46e6-883e-c2af64f01081</a> |<br>| — | — |</p><h2 id="2、DCNN"><a href="#2、DCNN" class="headerlink" title="2、DCNN"></a>2、DCNN</h2><p>DCNN（Dynamic Convolutional Neural Network）是在ACL 2014中提出的，主要用于对句子进行语义建模，以为后续的分类或生成任务奠定基础。模型采用动态的K—max pooling（取出得分top k的特征值）处理不同长度的句子，不依赖于解析树并且适用于任何语言，利用宽卷积和k-max pooling采样，构造了一种类似parse tree的结构，能够提取长距离的信息。DCNN的架构如下图。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665366396180-087d3ec0-9820-470f-bbcc-e8068d1034c8.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u79104718&margin=%5Bobject%20Object%5D&originHeight=1172&originWidth=930&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue5a8ac14-fa42-41f9-bd13-b7531bd0f2f&title="><br>图3 包含七个词的输入句子的DCNN。词嵌入的大小为d&#x3D;4。该网络有两个卷积层，每个层有两个特征图。这两个层的过滤器的宽度分别为3和2，k-max集合层的k值为5和3<br>1）嵌入。这一步骤和一般的网络没有区别，将输入句子s中的每个词w映射为d维向量，同时在训练的过程中对初始化的向量进行修改。</p><p>2）宽卷积。卷积部分用的是one-dim卷积，也就是filter的height固定为1。此外，宽卷积指的是在卷积操作时对输入矩阵的边缘进行padding补零，这样的好处是不会丢失边缘信息，其输出使feature map 的宽度更宽。</p><p>3）动态 k-Max Pooling。k-max pooling是max-pooling更一般的形式，相比后者，k-max在序列p中，p&gt;&#x3D;k，提取出序列中前k个最大的值，同时保留它们的相对顺序。k-max pooling的好处在于提取了句子中不止一个的重要信息，保留了它们的相对位置。并且由于最后的卷积层只需提取K个值，所以允许不同长度的输入，只要大于K。动态k-max pooling的意义在于，从不同长度的句子中提取出相应数量的语义特征信息，以保证后续的卷积层的统一性。比如，在情感预测中，首要特征所对应的单词提取出K1个，次要特征提取出k2个单词。</p><p>4）非线性特征函数。在k-max pooling之后，与传统的CNN一样，对于pooling后的结果加上一个偏置b进行非线性激活。</p><p>5）多个feature map。与传统CNN一样，会提取出多个featured map以保证提取特征的多样性。</p><p>6）折叠操作。之前的宽卷积是在输入矩阵d×s中的每一行内进行计算操作，其中d是word vector的维数，s是输入句子的词语数量。而折叠操作则是考虑相邻的两行之间的某种联系，将两行的vector相加；该操作没有增加参数数量，但是提前（在最后的全连接层之前）考虑了特征矩阵中行与行之间的某种关联，从而在没有增加任何参数的情况下，能够在全连接层之前提前考虑到词向量维度上的某些关联。</p><h2 id="3、XML-CNN"><a href="#3、XML-CNN" class="headerlink" title="3、XML-CNN"></a>3、XML-CNN</h2><p>XML-CNN发表在SIGIR 2017。这篇论文主要解决的是extreme multi-label(XML)问题，即，标签种类特别多，达到成百、上千的级别。在这种extreme multi-label情况下，容易出现数据稀疏问题，即某个label可能只有一条数据。此外，由于标签量级高，往往导致训练和预测计算量大。为了解决上述问题，作者提出利用CNN来解决XML问题。XML-CNN的架构如下图所示，从现在的角度来看，这一架构是比较简单的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665383227053-ddccbdc3-ec96-4606-9d83-61a7cad5a58e.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u14ec5252&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua46b97cd-d811-4d20-999b-7e4452de102&title="><br>图4 XML-CNN与样本例句。XML-CNN整体包括：嵌入层（Embedding Layer）、卷积层（Convolutional Layer）、池化层（Pooling Layer）、全连接层（FC）、分类层（sigmoid output）<br>1）嵌入层。嵌入层的输入为一个文本，文本由m个word组成，词向量维度为k，可以通过word2vec、fasttext等工具预训练得到词向量，也可以随机初始化生成。嵌入层的输出为文本向量。</p><p>2）卷积层。应用窗口大小为h（h-gram）进行卷积操作，主要目的是提取label对应的词特征。</p><p>3）池化层。池化层是应用NLP的必选步骤。一般主要应用Max-pooling以保留最显著的特征，过滤掉其它不重要的特征，同时降低模型复杂度。XML-CNN使用的是Dynamic K-Max-Pooling，与DCNN相同。</p><p>4）全连接层。XML-CNN在池化和输出层之间增加了一个全连接层，在论文中称为hidden bottleneck layer，即全连接层的隐藏单元数量远小于前后两个层的隐藏单元数量。XML-CNN中引入全连接层的原因一是池化层的单元太多，导致计算量太大；二是隐藏单元太多，不利于后面的表达和预测。</p><p>5）输出层。最终的输出层即为分类层。XML-CNN采用的是sigmoid函数，损失函数为binary entropy loss。</p><table><thead><tr><th>XML-CNN</th><th><a href="https://sota.jiqizhixin.com/models/models/06a8ba14-a96e-404b-b47a-549b606c9b3d">https://sota.jiqizhixin.com/models/models/06a8ba14-a96e-404b-b47a-549b606c9b3d</a></th></tr></thead></table><h2 id="4、TextCapsule"><a href="#4、TextCapsule" class="headerlink" title="4、TextCapsule"></a>4、TextCapsule</h2><p>TextCapsule发表在EMNLP 2018，探索将动态路由的胶囊网络与CNN相结合（区别于RNN-Capsule）。TextCapsule的架构如下图所示，主要包括四层：n-gram的卷积层、初始胶囊层、卷积胶囊层和全连接的胶囊层。另外，提出两个胶囊网络连接这4部分。<br> <img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665383385275-40bbdf95-bde0-43d1-b8f9-287945f06d0a.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue236bd7c&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3cfb78ac-81e0-406f-b7a6-53602277f4c&title="></p><p> 图5 TextCapsule架构图</p><p> 1）N-gram卷积层。该层是标准的卷积层，它通过各种卷积过滤器提取句子不同位置的n-gram特征。输入x为句子的表示，其中，x_i为对应于句子中第i个单词的V维单词向量。输出为B个特征图，B为过滤器数量。</p><p>2）初始胶囊层。这是第一层胶囊层，其中，胶囊用矢量输出胶囊替换CNN的标量输出特征检测器，以保留实例化的参数，例如单词的局部顺序和单词的语义表示。</p><p>3）动态路由。动态路由的基本思想是以迭代方式构造一个非线性映射，以确保每个胶囊的输出被发送到后续层中的适当父级。对于每个潜在的父对象，胶囊网络都可以通过动态路由来增加或降低各个神经元的连接强度，这比DNN中原始路由策略（Max-pooling）更为有效，该策略基本上可以检测文本的任何位置是否存在特征， 但会丢失有关要素的空间信息。作者探索了三种策略，可通过减轻某些噪声胶囊的干扰来提高路由过程的准确性：（i）孤立类别：向网络中添加了一个额外的“孤立”类别，目的是捕获文本的“背景”信息，例如停用词和与特定类别无关的词，从而帮助胶囊网络更有效率地为孩子父母关系建模。（ii）Leaky-Softmax。引入Leaky-Softmax以取代标准softmax，同时更新子胶囊与其父母之间的连接强度。尽管在最后一个胶囊层中引入了孤立类别，我们还需要在两个连续的层之间使用轻量级方法来将噪声子胶囊路由到额外的维度，而无需任何其他参数和计算量。（iii）系数修正。使用下层子胶囊中实体存在的概率来迭代地修改连接强度。</p><p>4）卷积胶囊层。在这一层中，每个胶囊仅连接到下层空间上的局部区域K_2 × C 。该区域中的胶囊会乘以转换矩阵以学习父子之间的关系，然后通过协议路由以在上一层中生成父胶囊。</p><p>5）全连接胶囊层。将下层中的胶囊平铺为一个胶囊列表，并带入到全连接胶囊层中，将胶囊乘以变换矩阵后进行协议路由，从而为每个类别生成最终胶囊和概率。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665384231748-825eca74-1e43-40cd-91f5-11e7fceb6bb1.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u905d324e&margin=%5Bobject%20Object%5D&originHeight=995&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1c4cc776-2a2f-4c33-a4dd-ae1bb9fb535&title="><br>图6 两种胶囊网络架构<br>与RNN-Capsule类似，TextCapsule也提出了两种胶囊网络架构，如图6所示。Capsule-A从嵌入层开始，将语料库中的每个词转化为300维（V &#x3D; 300）的词向量，然后是一个具有32个滤波器（B &#x3D; 32）、步长为1的ReLU非线性的3-gram（K1 &#x3D; 3）卷积层。所有其他层都是胶囊层，从具有32个滤波器（C&#x3D;32）的B×d初级胶囊层开始，然后是具有16个滤波器（D&#x3D;16）的3×C×d×d（K2&#x3D;3）卷积胶囊层和一个全连接的胶囊层，依次进行。每个胶囊都有16维（d&#x3D;16）的实例化参数，其长度（规范）可以描述胶囊存在的概率。胶囊层由转换矩阵连接，每个连接也要乘以路由系数，该系数由路由协议机制动态计算得出。</p><p>Capsule-B的基本结构与Capsule-A相似，只是在N-gram卷积层中采用了三个平行网络，过滤窗口（N）为3、4、5。全连接的胶囊层的最终输出被送入平均池以产生最终结果。通过这种方式，Capsule-B可以学习到更有意义和全面的文本表示。</p><table><thead><tr><th>TextCapsule</th><th><a href="https://sota.jiqizhixin.com/models/models/3a9c6a86-16be-4d75-9a65-353bdcdffc18">https://sota.jiqizhixin.com/models/models/3a9c6a86-16be-4d75-9a65-353bdcdffc18</a></th></tr></thead></table><table><thead><tr><th>Bao et al.</th><th><a href="https://sota.jiqizhixin.com/models/models/d7a53e59-7faa-4258-904c-d1fd8a716b88">https://sota.jiqizhixin.com/models/models/d7a53e59-7faa-4258-904c-d1fd8a716b88</a></th></tr></thead></table><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>CNN和RNN在文本分类任务中表现出色。然而，这些模型不够直观，可解释性差，特别是在分类错误中，由于隐藏数据的不可读性而无法解释。随后，基于注意力的方法被成功地应用于文本分类中。基于注意力的模型架构如图8。注意力机制让模型对特定的输入给予不同的注意。它首先将重要的词聚集成句子向量，然后将重要的句子向量聚集成文本向量。它可以了解每个词和句子对分类判断的贡献有多大，这有利于通过两个层次的关注进行应用和分析。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665384524690-c117b49c-2054-41b6-a9ca-5ff00414d8bd.png#clientId=u92da87b6-5fd9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udfaf4c2e&margin=%5Bobject%20Object%5D&originHeight=771&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u29a11c7c-6a75-4691-a071-c7e9dfd1423&title="><br>图8 注意力机制架构</p><h2 id="1、AttentionXML"><a href="#1、AttentionXML" class="headerlink" title="1、AttentionXML"></a>1、AttentionXML</h2><p><a href="https://sota.jiqizhixin.com/models/models/839883d4-569c-4d5c-9457-e5a374375875">https://sota.jiqizhixin.com/models/models/839883d4-569c-4d5c-9457-e5a374375875</a></p><h1 id="三、Transformer"><a href="#三、Transformer" class="headerlink" title="三、Transformer"></a>三、Transformer</h1><table><thead><tr><th>模型</th><th>SOTA！模型资源站收录情况</th><th>模型来源论文</th></tr></thead><tbody><tr><td>ELMo</td><td><a href="https://sota.jiqizhixin.com/models/models/e473edac-88cc-4a83-b533-d15c2ca0ea17">https://sota.jiqizhixin.com/models/models/e473edac-88cc-4a83-b533-d15c2ca0ea17</a></td><td></td></tr><tr><td>收录实现数量：3</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow、PyTorch、MXNet 等</td><td>Deep Contextualized Word Representations</td><td></td></tr><tr><td>GPT</td><td><a href="https://sota.jiqizhixin.com/models/models/09877886-65c3-44b0-a5be-9e5043964787">https://sota.jiqizhixin.com/models/models/09877886-65c3-44b0-a5be-9e5043964787</a></td><td></td></tr><tr><td>收录实现数量：1</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow、PyTorch</td><td>Improving language understanding by generative pre-training</td><td></td></tr><tr><td>BERT</td><td><a href="https://sota.jiqizhixin.com/models/models/1d27a74a-8668-4d64-9615-ce889b88700b">https://sota.jiqizhixin.com/models/models/1d27a74a-8668-4d64-9615-ce889b88700b</a></td><td></td></tr><tr><td>收录实现数量：7</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow、PyTorch 等</td><td>BERT: pre-training of deep bidirectional transformers for language understanding</td><td></td></tr><tr><td>ALBERT</td><td><a href="https://sota.jiqizhixin.com/models/models/0306236e-ce20-4886-98cb-45730fda6cf9">https://sota.jiqizhixin.com/models/models/0306236e-ce20-4886-98cb-45730fda6cf9</a></td><td></td></tr><tr><td>收录实现数量：13</td><td></td><td></td></tr><tr><td>支持框架：PyTorch、TensorFlow、CANN</td><td>ALBERT: A lite BERT for self-supervised learning of language representations</td><td></td></tr><tr><td>X-Transformer</td><td><a href="https://sota.jiqizhixin.com/models/models/fa67640c-fedb-400e-a6fb-e83b4eedbb65">https://sota.jiqizhixin.com/models/models/fa67640c-fedb-400e-a6fb-e83b4eedbb65</a></td><td></td></tr><tr><td>收录实现数量：1</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow</td><td>Taming pretrained transformers for extreme multi-label text classification</td><td></td></tr><tr><td>LightXML</td><td><a href="https://sota.jiqizhixin.com/models/models/7f477837-72fe-435d-b8e4-13d5308c7bfa">https://sota.jiqizhixin.com/models/models/7f477837-72fe-435d-b8e4-13d5308c7bfa</a></td><td></td></tr><tr><td>支持框架：PyTorch</td><td>Lightxml: Transformer with dynamic negative sampling</td><td></td></tr><tr><td>for high-performance extreme multi-label text classification</td><td></td><td></td></tr><tr><td>TextGCN</td><td><a href="https://sota.jiqizhixin.com/models/models/64a6edf7-3e03-455c-bb54-26ab72607c0e">https://sota.jiqizhixin.com/models/models/64a6edf7-3e03-455c-bb54-26ab72607c0e</a></td><td></td></tr><tr><td>收录实现数量：1</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow</td><td>Graph convolutional networks for text classification</td><td></td></tr><tr><td>TensorGCN</td><td><a href="https://sota.jiqizhixin.com/models/models/2702592d-f69f-41a6-9c29-924999576bd3">https://sota.jiqizhixin.com/models/models/2702592d-f69f-41a6-9c29-924999576bd3</a></td><td></td></tr><tr><td>收录实现数量：1</td><td></td><td></td></tr><tr><td>支持框架：TensorFlow</td><td>Tensor graph convolutional networks for text classification</td><td></td></tr></tbody></table><h2 id="1、Pre-train"><a href="#1、Pre-train" class="headerlink" title="1、Pre-train"></a>1、Pre-train</h2><p>预训练的语言模型可以有效地学习全局语义代表，并显著提升NLP任务的效果，包括文本分类。它通常使用无监督的方法来自动挖掘语义知识，然后构建预训练目标，使机器能够学习理解语义。如图1所示，我们给出了Embeddingfrom Language Model (ELMo)、OpenAI GPT和BERT之间模型架构的差异。ELMo是一个深度的语境化单词表示模型，它很容易被整合到模型中。它可以对单词的复杂特征进行建模，并为各种语言环境学习不同的表示方法。它根据双向LSTM的上下文词来学习每个词的嵌入。GPT采用有监督的微调和无监督的预训练来学习一般的表征，这些表征在有限的适应下转移到许多NLP任务。此外，目标数据集的领域不需要与未标记的数据集的领域相似。GPT算法的训练过程通常包括两个阶段。首先，神经网络模型的初始参数是通过在未标记的数据集上的建模目标学习的。我们可以采用相应的监督目标来适应目标任务的这些参数。谷歌提出的BERT模型，通过对每一层的左右上下文进行联合调节，从未标记的文本中预训练出深层次的双向表征，显著提高了NLP任务的性能，包括文本分类。BERT应用了双向编码器，旨在通过联合调整所有层的上下文来预先训练深度的双向表示。它可以在预测哪些词被掩盖时利用上下文信息。它只需增加一个额外的输出层就可以进行微调，为多个NLP任务构建模型。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665400887880-9a2dfc91-7138-4ec8-9719-79678f794822.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub5213396&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u053343b2-35df-4b30-b150-32a3c27a11b&title="><br>与这三个模型相比，ELMo是一种使用LSTM的基于特征的方法，而BERT和OpenAI GPT是使用Transformer的微调方法（也可以归类到本文第七类Transformer模型里，为了表述清晰，本文将GPT和BERT放入Pre-train类别中介绍）。此外，ELMo和BERT是双向训练模型，而OpenAI GPT是从左到右的训练。因此，BERT得到了一个更好的结果，它结合了ELMo和OpenAI GPT的优点。</p><h2 id="2、ELMo"><a href="#2、ELMo" class="headerlink" title="2、ELMo"></a>2、ELMo</h2><p>词向量模型ELMo的相关论文发表在NAACL 2018上。具体的方法是将每个词的表示看作是对于整体句子的函数，通过利用在语料上训练的双向LSTM的语言模型得到词向量，因此将其称为ELMo(Embeddings from Language Models)。对比传统Word2Vec这种静态形式的词向量，ELMo是一种动态模型。对于静态形式的词向量来说，无论在任何的上下文中都使用同一个向量，因此很难表示一词多义的现象，而ELMo则可以通过上下文动态生成词向量，从理论上会是更好的模型，从实测效果来看在很多任务上也都达到了当时的SOTA成绩。ELMo引入了上下文语境的概念。ELMo的架构如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401462267-016982c7-8f31-4c42-ac89-ce60fad8930c.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2c099ec6&margin=%5Bobject%20Object%5D&originHeight=542&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2521f996-2839-4dbc-b685-ed512e5edce&title=">图2 ELMo架构<br>首先介绍双向语言模型biLM，这是ELMo的基础。给定N个tokens的序列，一个前向语言模型通过对t_o的概率进行建模来计算t_k的概率：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401601612-3427754b-5493-49b2-b8e0-328c2d1d4ae8.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=88&id=u90af6f74&margin=%5Bobject%20Object%5D&originHeight=156&originWidth=893&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue54b1626-937a-4753-a187-2718710531d&title=&width=501"><br>而双向语言模型就是添加了另一个方向的预测，利用N~k+1个token来预测第k个token：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401616286-df9ac0f3-a680-4410-88cc-7a0f591ceed3.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=82&id=uae3c14a2&margin=%5Bobject%20Object%5D&originHeight=149&originWidth=967&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3cfa2aca-ae71-4709-9d54-d198a8c765f&title=&width=532"><br>目标函数则是上述两者的联合损失（BiLM）：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401630236-797671f0-b67c-4c78-a006-821729c28db0.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=104&id=u9bb95a09&margin=%5Bobject%20Object%5D&originHeight=256&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued22b1b2-8689-42c8-ad83-5a6b4999394&title=&width=440"><br>不同于其他类型的模型采用最顶层的输出作为token的表示，ElMo采用多个层的线性加和作为token的表示，对于每个token，在一个L层的biLm中可以输出2L+1表示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401645857-4d13dcb8-20cb-41d5-b976-e3555debedca.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=92&id=uc04468d1&margin=%5Bobject%20Object%5D&originHeight=193&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u27556eb6-4acf-47c4-96ec-7421029e100&title=&width=513"><br>在下游任务中，可以将上述2L+1个表示进行整合：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665401664132-985b6d61-56ea-467e-bb6c-7ca81b7e8332.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=u5afded3d&margin=%5Bobject%20Object%5D&originHeight=164&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udce531b3-e921-4c0e-a347-03e50245b22&title=&width=512"><br>具体到ELMo的架构，还是按照训练语言模型的方式，使用了CNN-BIG-LSTM结构和一个层之间的残差链接。使用ELMo可以针对一个token产生三个向量,：原始向量、第一层向量、第二层向量。作者认为低层的bi-LSTM层能提取语料中的句法信息，而高层的bi-LSTM能提取语料中的语义信息。</p><p>| ### ELMo</p><p> | <a href="https://sota.jiqizhixin.com/models/models/e473edac-88cc-4a83-b533-d15c2ca0ea17">https://sota.jiqizhixin.com/models/models/e473edac-88cc-4a83-b533-d15c2ca0ea17</a> |<br>| — | — |</p><h2 id="3、GPT"><a href="#3、GPT" class="headerlink" title="3、GPT"></a>3、GPT</h2><p>GPT是“Generative Pre-Training”的简称，是指的生成式的预训练。GPT的训练程序包括两个阶段。第一阶段的预训练是在一个大型文本语料库上学习一个高容量的语言模型。接下来是一个微调阶段，在这个阶段，使模型适应带有标记数据的判别性任务。</p><ul><li>第一阶段的工作具体为：Embedding——&gt;Transformer——&gt;Text Production。</li><li>第二阶段的工作具体为：将下游任务的网络结构改造成和GPT的网络结构是一样的；利用第一步预训练好的参数初始化GPT的网络结构完成下游任务，这样通过预训练学到的语言学知识就被引入到任务里了；使用下游任务去训练这个网络，对网络参数进行Fine-tuning，使得这个网络更适合解决任务的问题。</li></ul><p>对于特定任务的输入转换，使用了一种遍历式的方法，将结构化的输入转换成预先训练好的模型可以处理的有序序列。图3提供了一个可视化的说明。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665402048867-897707af-b7a7-49f9-b3d5-3db1103c5f8f.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b6e0c12&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u30ae7708-a976-4d94-a346-645ceed2ec2&title="><br><strong><em>图3 左）GPT中使用的Transformer结构和训练目标。(右) 输入在不同的任务上进行微调的转化。将所有结构化的输入转化为标记性的序列，由预训练模型处理，然后是一个线性+softmax层</em></strong></p><table><thead><tr><th>GPT</th><th><a href="https://sota.jiqizhixin.com/models/models/09877886-65c3-44b0-a5be-9e5043964787">https://sota.jiqizhixin.com/models/models/09877886-65c3-44b0-a5be-9e5043964787</a></th></tr></thead></table><h2 id="4、BERT"><a href="#4、BERT" class="headerlink" title="4、BERT"></a>4、BERT</h2><p>BERT（Bidirectional Encoder Representations from Transformers）自从谷歌提出就一直大热，很多人认为BERT是整个NLP研究历程中里程碑似的节点。BERT与ELMo提出，一经提出就明显胜过了ELMo。BERT的灵感来源是OpenAI在17年发布过的一篇名为“Attention is all your need”论文中提到的Transformer模型。关于Transformer的相关模型我们放在第七个章节中具体介绍，本章节内BERT是作为一类预训练模型介绍的。</p><p>首先，BERT在NLP的11个任务（包括文本分类任务）中均有较大程度性能提升。其次，BERT在无监督场景下结合预训练能够最大化地利用文本数据，同时对不同场景的下游任务均有提升和帮助。BERT的基础建立在Transformer之上，拥有强大的语言表征能力和特征提取能力，同时再次证明了双向语言模型的能力更加强大。<br>首先，BERT在NLP的11个任务（包括文本分类任务）中均有较大程度性能提升。其次，BERT在无监督场景下结合预训练能够最大化地利用文本数据，同时对不同场景的下游任务均有提升和帮助。BERT的基础建立在Transformer之上，拥有强大的语言表征能力和特征提取能力，同时再次证明了双向语言模型的能力更加强大。</p><p>BERT的网络结构使用了双向Transformer的堆叠，Encoder和Decoder分别12层。其思想出于ELMo和GPT但同时又高于二者。ELMo采用了双向LSTM来训练词Embedding，虽然使用了双向LSTM，但其实是使用2个单向LSTM对学到的句子语义信息做拼接，和BERT完全双向不同，对句子间不同词的语义依赖关系也不如BERT捕捉的充分。GPT只有单向，其假设句子间语义依赖关系只有从左到右，而没有从右到左，该假设在实际中并不完全满足。BERT加入了Masked Language Model(MLM) 和 Next Sentences Prediction(NSP），使得模型能够在无监督的场景下学习到句子间特征和语义特征。在无监督学习场景训练，能最大化的使用训练语料。而Pre-train和Fine-tune能够方便地将已训练好的BERT模型迁移到不同的应用场景，在工业界大有益处。</p><p>图1最右侧为BERT的架构，可以看出BERT的最大亮点：<strong>双向Transformer网络，BERT直接引用了Transformer架构中的Encoder模块，并舍弃了Decoder模块, 这样便自动拥有了双向编码能力和强大的特征提取能力。</strong></p><p>下图为BERT的输入图示。由图示可知，BERT的输入包括三个部分：词嵌入张量（Token embeddings）、语句分块张量（ segmentation embeddings）、位置编码张量（position embeddings），最终的embedding向量是将上述的3个向量直接做加和的结果。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665402393369-3a6bc91e-adc4-41ee-9810-a083fa830c17.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua32c6e61&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5359fe12-d402-403b-ac74-c0042ac768f&title="><br>图4 BERT输入表示。输入嵌入是标记嵌入、分割嵌入和位置嵌入的总和。嵌入和位置嵌入的总和<br>接下来，<strong>MLM和 NSP是BERT的另外两个亮点</strong>：<br><strong>BERT中引入了一个带mask的语言模型训练（Masked LM）</strong>。在原始训练文本中，随机抽取15%的token作为即将参与mask的对象。在选中的token中，数据生成器并不是把他们全部变成[MASK]，具体变化方法包括三类：一是，在80%的概率下，用[MASK]标记替换token，比如my dog is hairy → my dog is [MASK]；二是，在10%的概率下，用随机单词替换token，比如my dog is hairy → my dog is apple；三是，在10%的概率下，保持token不变，比如my dog is hairy → my dog is hairy。</p><p><strong>BERT还引入了一个下句话预测任务（Next Sentence Prediction ）</strong>，目的是服务问答、推理、句主题关系等NLP任务。所有的参与任务训练的语句都被选中参加，其中：50%的B是原始本中实际跟随A的下句话；50%的B是原始本中随机抽取的一句话。在该任务中，BERT模型可以在测试集上取得97-98%的准确率。<br>最后，<strong>fine-tuning是BERT的另一个亮点</strong>，只需要将特定任务的输入，输出插入到BERT中，利用Transformer强大的注意力机制就可以模拟很多下游任务，从而具有极佳的迁移特性。</p><table><thead><tr><th>BERT</th><th><a href="https://sota.jiqizhixin.com/models/models/1d27a74a-8668-4d64-9615-ce889b88700b">https://sota.jiqizhixin.com/models/models/1d27a74a-8668-4d64-9615-ce889b88700b</a></th></tr></thead></table><h2 id="5、ALBERT"><a href="#5、ALBERT" class="headerlink" title="5、ALBERT"></a>5、ALBERT</h2><p>ALBERT（A Lite BERT）被称为Lite版的Bert，相关论文发表在ICLR 2020。ALBERT采用了两种技术来减少参数量，以应对扩展预训练模型的主要障碍。</p><ul><li><strong>第一个是因子化嵌入参数化。</strong>通过将大型词汇嵌入矩阵分解成两个小矩阵，将隐藏层的大小与词汇嵌入的大小分开。这种分离使得在不显著增加词汇嵌入的参数大小的情况下更容易增长隐藏的大小。</li><li><strong>第二种技术是跨层参数共享。</strong>这种技术可以防止参数随着网络的深度而增长。这两种技术都大大减少了BERT的参数数量而不严重损害性能，从而提高了参数效率。类似于BERT的ALBERT配置的参数减少了18倍，训练速度可以提高1.7倍左右。减少参数的技术也作为一种正则化的形式，稳定了训练并有助于泛化。为了进一步提高ALBERT的性能，还引入了一个用于句序预测的自监督损失（sentence-order prediction，SOP）。SOP主要关注句子间的连贯性，旨在解决原始BERT中提出的下句预测（NSP）损失的无效性。</li></ul><p><strong>ALBERT架构的主干与BERT相似，因为它使用具有GELU非线性的Transformer encoder。将词汇embedding size表示为E，将encoder layers层数表示为L，将hidden size表示为H，将feed forward&#x2F;filter size设置为4H，多头注意力的数量设置为H &#x2F; 64。</strong></p><p>让BERT模型变大（scale up）的方法一般有两种：变深（增加模型的层数）、变宽 （增加隐藏尺寸，即每一层embeddings的特征数），ALBERT的方式是第二种。具体ALBERT的改进点如下所示：</p><ul><li>Factorized Embedding Parameterization（将初始嵌入缩短为128个特征）。对于词向量维度 E 和隐层维度 H，在词表 V 到 H 的中间，插入一个小维度 E，多做一次尺度变换：O(VxH) →  O(VxE+ExH)。</li><li>Cross-layer Parameter Sharing（共享所有层的参数）。具体分为三种模式：只共享 attention 相关参数、只共享 FFN 相关参数、共享所有参数（attention相关+FFN）。全共享如下图所示：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665402762274-6f7ca780-c02f-48cb-95e6-bc9c3be0561e.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7311ef9a&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=300&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4a5fac66-85a5-41c3-b641-766e2b159ff&title="><br> 图5  ALBERT全共享参数</p><ul><li>Sentence Order Prediction（SOP）。SOP 就是让模型预测两个相邻 segments 有没有被调换前后顺序。SOP主要是针对NSP提出的，即句子顺序判断。NSP将话题预测和连贯性预测混合在一个任务中。然而，与连贯性预测相比，话题预测更容易学习，而且与使用MLM[掩蔽语言建模]损失学习的内容重叠更多。因此，ALBERT提出一个主要基于连贯性的损失，即句序预测（SOP）损失，它避免了话题预测，侧重于对句子间的一致性进行建模。</li><li>此外，还包括用长句做预训练、随机遮连续的多个词（Masked-ngram-LM vs Masked LM）、扩大模型参数、增加预训练数据、去掉Dropout层等trick。<table><thead><tr><th>ALBERT</th><th><a href="https://sota.jiqizhixin.com/models/models/0306236e-ce20-4886-98cb-45730fda6cf9">https://sota.jiqizhixin.com/models/models/0306236e-ce20-4886-98cb-45730fda6cf9</a></th></tr></thead></table></li></ul><h1 id="四、Transfomer"><a href="#四、Transfomer" class="headerlink" title="四、Transfomer"></a>四、Transfomer</h1><p>基于Transformer的模型可以在不考虑顺序信息的情况下将计算并行化，适用于大规模的数据集，使其在NLP任务中很受欢迎。Transformer由17年一篇著名论文“Attention is All Your Need”提出的。在这篇论文中，作者提出了一种全新的注意力机制— self-Attention，做到了仅仅利用Attention代替了传统的RNN，实现了快速并行计算，挖掘了DNN的特性。</p><p>Transformer主要分为两个部分：编码组件+解码组件，与传统的RNN编码、解码的结构很像。Transformer的编码组件由多个encoder(编码器)堆叠而成。每个encoder又有两个子层，分别是 FFN(前馈神经网络) + self-Attention(自注意力层)。FFN就是MLP（多层感知器架构）。而self-Attention层的输入是一个单词经过词嵌入处理的句子，也就是一个词向量列表，输出是结合了句子本身上下文注意力之后的融合向量。此外，为了能够从不同角度捕捉不同的关联程度，Transformer利用了一种”多头”的self-Attention机制。即一个self-Attention层拥有多组WQ 、WK 、WV ，每组分别用于不同的特征提取，把所有“头”通过一个高维矩阵W0 。Transformer的架构如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403035375-f757a82e-8a4c-49ec-badf-64dba3076ede.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u00bf8b08&margin=%5Bobject%20Object%5D&originHeight=685&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf6614e57-d875-48c9-8af8-3f6e21a970d&title="><br>图 6 Transfomer架构图<br>我们在之前介绍过，BERT系列模型其实也是Transformer模型，但归类为预训练的方法进行了介绍。本章节则聚焦于专门的Transformer系列模型。</p><h2 id="1、X-Transformer"><a href="#1、X-Transformer" class="headerlink" title="1、X-Transformer"></a>1、X-Transformer</h2><p>X-Transformer的工作发表在KDD 2020中，主要针对的是极端多标签（Extreme Multi-label  XML）文本分类问题，即给定输入文本，从大型标签集中返回最相关的标签。因此，X-Transformer也是聚焦于稀疏的巨大标签空间问题（XML-CNN、AttentionXML等），只不过方法是deep transformer结构。X-Transformer的架构如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403135446-35ae7ad1-c747-4285-bd65-4b24b62348f5.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fcedebc&margin=%5Bobject%20Object%5D&originHeight=314&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud84cfab8-9a4b-49c3-b88d-bf408420b14&title="></p><p><strong><em>图7 X-Transformer框架。首先，语义标签索引减少了庞大的输出空间。然后在XMC子问题上对Transformer进行微调，该子问题将实例映射到标签集群。最后，在集群和转化器的输出上有条件地训练线性排名器，以便在预测的集群中对标签进行重新排名</em></strong><br>1）语义标签索引（Semantic Label Indexing，SLI）。利用层次聚类将XMC问题转化为更小的K个输出空间的子问题。给定一个训练集D，XML的目的是学习一个评分函数f，将输入（或实例）x_i和 一个标签l映射到一个分数f(x_i, l) ∈R。优化函数f，以满足当y_il&#x3D;1时得分高（即，标签l与实例x_i有关），而当y_il&#x3D;0时，得分较低：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403178934-82e41d18-daf8-4597-9c94-7e6e836ac5c6.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=83&id=u60609a70&margin=%5Bobject%20Object%5D&originHeight=180&originWidth=842&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u99e2a40d-f260-4b21-ab81-4499dc6f963&title=&width=388"><br>其中，ϕ(x)代表一个编码，W 是分类器的瓶颈层。ϕ(x)的编码采用两种方式：一是，通过标签文本嵌入标签，利用XLNET的对每一个token进行词嵌入(token_dim&#x3D;1 × 1024 )后求和然后平均池化得到标签的向量表示；二是，通过正面实例的嵌入进行标签嵌入。<br>2）作为神经匹配器的deep Transformer。经过SLI，原来难以解决的XML问题演变成了一个可行的XML子问题，其输出空间大小为K，是一个非常小的数。应用deep Transformer将每个文本实例映射到指定的相关集群。构建分类器：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403201804-1862fedd-a347-4d97-975d-9f22fad3d140.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=55&id=ub54f1737&margin=%5Bobject%20Object%5D&originHeight=104&originWidth=1028&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9dc548ea-2e0e-4184-aac4-bbf0e92ff0b&title=&width=544"><br>训练时的Loss为squared hinge loss：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403216449-30dbbf5b-de03-4fa9-b093-fce5362070f7.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=100&id=uac3bc3b7&margin=%5Bobject%20Object%5D&originHeight=267&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u270dfc77-a618-4f49-90f8-f3b0b84cb1f&title=&width=405"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403226870-2b43b877-7599-415a-ba9d-d98593568877.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=35&id=u07bc8466&margin=%5Bobject%20Object%5D&originHeight=58&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9a113350-e763-4169-881d-6fe4bf8d109&title=&width=658"><br>3）排序。用一个线性排序器对所属簇类标签进行排序。引入两个tricks：一是，Teacher Forcing Negatives (TFN)。为了在反向更新权重时提升运算效率并节省运算空间，在back propagation时一般都要进行负采样。本文在负采样抽样时只包含了与groudtruth l 标签属于同一簇的实例。二是，Matcher-aware Negatives (MAN)。为了解决exposure bias的问题，选择使用了MAM方法。该方法借鉴了Scheduled Sampling的思路，将groudtruth与上一个隐状态预测的label所在的簇相互融合。</p><p>| ### X-Transformer</p><p> | <a href="https://sota.jiqizhixin.com/models/models/fa67640c-fedb-400e-a6fb-e83b4eedbb65">https://sota.jiqizhixin.com/models/models/fa67640c-fedb-400e-a6fb-e83b4eedbb65</a> |<br>| — | — |</p><h2 id="2-Light-XML"><a href="#2-Light-XML" class="headerlink" title="2. Light - XML"></a>2. Light - XML</h2><p>Light-XML是AAAI2021中最新的关于Transformer的模型，也是针对于XML问题提出的。在我们前面的介绍中，<strong>AttentionXML和X-Transformer存在两个共同的问题：一是，模型既大又多。对于一个数据集，AttentionXML需要训练四个模型。X-Transformer也需要分阶段训练两个模型。二是，负采样策略都关注于一些困难样本，或者说与正样本相似的样本，此种采样方法较难使得模型收敛。</strong>LightXML的思路是：结合Transformer和Generative Cooperative Networks将分阶段模型变成End-to-End模型，同时使用动态负采样策略让模型更容易收敛，从而获得更好的效果。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403381649-3282b9c5-2610-49b6-a637-89184747047d.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4ec5f452&margin=%5Bobject%20Object%5D&originHeight=628&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua0c98dc0-3d7c-4776-8923-6d61f2abd1a&title="><br>图 8  Light-XML 架构图<br>1）标签聚类。聚类方法与AttentionXML相同。由于两层的标签树以及足够处理XML问题，因此只设置了两层的标签树。<br>2）文本表征。与X-Transformer相同，采用了三种预训练Transformer模型，BERT、XLNet、RoBERTa。区别在于Light-XML对于小型的XML数据集采用了512的输入长度，以及concatenate最后五层的[CLS]表示，作为模型输出。<br>3)标签回溯。生成器：经过一个sigmoid激活的全连接网络(原文中称为Generator)，生成K个标签簇的分数。选择其中top-b个标签簇的所有标签作为候选标签。在训练阶段会为候选标签加入所有positive的标签。使用交叉熵作为Generator的损失。动态负标签采样（Dynamically NLS）：X-Transformer&#x2F;AttentionXML是在第一阶段模型训练完成后，将其结果作为负采样的依据。而动态负采样方法对于同一个训练样本，其负标签在每一个epoch下重新采样，从而能够保证负样本由易到难，同时防止过拟合。<br>4）排序。标签嵌入：通过随机初始化的标签嵌入矩阵获取候选标签的嵌入；Hidden Bottleneck Layer：参考上文我们介绍的XML-CNN的设置，在分类层和表示层之间加入一个低维的全连接层，起到降低参数量和增强非线性的作用。Discriminator：压缩原始文档表示，与标签嵌入相乘后得到最终所有候选标签的分数。最终使用交叉熵损失。</p><table><thead><tr><th>Light - XML</th><th><a href="https://sota.jiqizhixin.com/models/models/7f477837-72fe-435d-b8e4-13d5308c7bfa">https://sota.jiqizhixin.com/models/models/7f477837-72fe-435d-b8e4-13d5308c7bfa</a></th></tr></thead></table><h1 id="五、GNN"><a href="#五、GNN" class="headerlink" title="五、GNN"></a>五、GNN</h1><p>随着图神经网络（GNN）的关注度越来越高，基于GNN的模型通过对句子的句法结构进行编码，在语义角色标签任务、关系分类任务和机器翻译任务中获得了出色的表现。它将文本分类变成了一个图节点分类任务。我们展示了一个用于文本分类的GCN模型，有四个输入文本，如下图所示。首先，将四个输入文本𝑇&#x3D;[𝑇1,𝑇2,𝑇3,𝑇4]和文本中的词𝑋&#x3D;[𝑥1, 𝑥2, 𝑥3, 𝑥4, 𝑥5, 𝑥6]定义为节点，构造成图结构。图形节点由黑色粗边连接，这表示文档-词边和词-词边。每个词-词边缘的权重通常意味着它们在语料库中的共同出现频率。然后，单词和文本通过隐藏层表示。最后，所有输入文本的标签可以通过图来预测。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403660108-78302138-113f-4848-b3ca-f572d16b5bfd.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc8fe62df&margin=%5Bobject%20Object%5D&originHeight=367&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9c15241a-f96c-42db-934b-2c7cff1a811&title="><br><strong><em>图9 基于GNN的模型。初始图的不同取决于图的设计方式。给出一个例子，在文档与文档、文档与句子、词与词之间建立边</em></strong></p><h2 id="1、TextGCN"><a href="#1、TextGCN" class="headerlink" title="1、TextGCN"></a>1、TextGCN</h2><p>TextGCN的文章发表在AAAI 2019中。TextGCN从整个语料库中构建了一个大图，其中包含了作为节点的词和文件，使用图卷积网络（Graph Convolutional Network，GCN）对该图进行建模，这是一个简单而有效的图形神经网络，可以捕捉到高阶邻域信息。两个词节点之间的边缘是由词的共现信息建立的，而一个词节点和文档节点之间的边缘是用词频和词的文档频率建立的。然后，<strong>将文本分类问题转化为节点分类问题。</strong>该方法可以在标注文档比例较小的情况下实现强大的分类性能，并学习到可解释的词和文档节点嵌入。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665403809206-1878387f-2e8d-40dc-8347-3c651b0dad50.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5082a859&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1cdc3e3a-2b0f-45cc-b016-b739afcbb2c&title="><br><strong><em>图10 文本GCN的示意图。样本取自Ohsumed语料库。以 “O “开头的节点是文档节点，其他节点是词节点。黑色粗边是文档-词的边，灰色细边是词-词的边。R(x)表示x的表示（嵌入）。不同的颜色表示不同的文档类别。CVD：心血管疾病，Neo: 肿瘤，Resp: 呼吸道疾病，Immun: 免疫学疾病</em></strong><br>具体到TextGCN，其图卷积结构如下：<br>1）节点特征向量。把特征矩阵X &#x3D; I设置为一个单位矩阵，每个单词或文档都表示为one-hot向量，作为Text GCN的输入。</p><p>2）边权重。TextGCN根据单词在文档中的出现率（文档-单词边）和单词在整个语料库中的共现率（单词-单词边）来建立节点之间的边。一个文档节点和一个单词节点之间的边的权重是该单词在文档中的术语频率-逆文档频率（term frequency-inverse document frequency，TF-IDF），其中术语频率是该单词在文档中出现的次数，逆文档频率是包含该单词的文档数量的对数比例的反分数。具体来说，对语料库中的所有文档使用固定大小的滑动窗口来收集共现统计信息，采用点对点的相互信息（point-wise mutual information，PMI）来计算两个词语节点之间的权重。形式上，节点i和节点j之间的边的权重被定义为：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404150275-fe0eba1d-6e61-45a4-9182-ea557fdfa717.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=118&id=u59dbde5e&margin=%5Bobject%20Object%5D&originHeight=249&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uda482937-0a03-4dcb-800c-0f5aa711681&title=&width=513"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404207217-2dea8387-5e35-47e8-a1a4-3b726c553c81.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u7fa462ed&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=688&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf792413c-555e-4607-b618-4b43b3002a8&title=&width=285"><br>在建立文本图后，将图送入一个简单的两层GCN，第二层节点（词&#x2F;文档）嵌入的大小与标签集相同，并送入一个softmax分类器，最后再经过交叉熵做分类。两层的GCN可以允许最多两步远的节点之间的信息传递。因此，尽管图中没有直接的文档-文档边，但两层GCN允许文档对之间的信息交互。</p><table><thead><tr><th>TextGCN</th><th><a href="https://sota.jiqizhixin.com/models/models/64a6edf7-3e03-455c-bb54-26ab72607c0e">https://sota.jiqizhixin.com/models/models/64a6edf7-3e03-455c-bb54-26ab72607c0e</a></th></tr></thead></table><h2 id="2、TensorGCN"><a href="#2、TensorGCN" class="headerlink" title="2、TensorGCN"></a>2、TensorGCN</h2><p>TensorGCN相关论文发表在AAAI 2020中。TensorGCN构造一个文本图张量（<strong>多个图</strong>）来描述语义、句法和上下文信息。然后，对文本图张量进行了两种传播学习。第一种是图内传播，用于在单个图中聚合来自邻近节点的信息。第二种是图间传播，用于协调图之间的异构信息。TensorGCN提供了一种有效的方法来协调和集成来自不同类型图的异构信息，提升了文本分类的效果。TensorGCN的架构如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404398978-da65d6e2-db88-4aa6-a590-a94feba6e69b.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5ce64b6c&margin=%5Bobject%20Object%5D&originHeight=298&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uecb1bb71-0e00-4802-bcca-f12b5733289&title="><br><strong><em>图11 应用于文本分类的TensorGCN架构</em></strong><br>与TextGCN不同，TensorGCN应用的是张量图，张量中每个图的结点都是相同的，而结点之间的边以及权重不同。张量图表示为：G &#x3D;(G1;G2; ···;Gr)，其中Gi &#x3D; (Vi;Ei;Ai)，Vi表示第i个图张量的结点集合，对于从同一段文本派生出来的图张量，Vi&#x3D;Vj，Ai≠Aj。邻接矩阵也被定义成张量的形式：A &#x3D; (A1;A2; ··· ;Ar) ，其维度为r×n×n。<br>我们需要在节点之间建立两种边：词-文本边和词-字边。词-文本边是根据文档中出现的词建立的，边的权重用TF-IDF方法计算。根据三种不同的语言属性建立词-字边：语义信息、句法依赖和局部顺序语境。基于这些不同种类的词-字边，构建了一系列的文本图来描述文本文件。<br>1）Semantic-based graph。<br>（1）对指定任务的训练数据进行LSTM训练。<br>（2）使用LSTM获取语料库中每个文本&#x2F;句子中的所有单词的语义特征&#x2F;嵌入。<br>（3）根据语料库上的词的语义嵌入计算word-word的边权重。对于每个句子&#x2F;文本，从训练后的LSTM输出中获得单词的语义特征&#x2F;嵌入，并计算单词之间的余弦相似度。当相似度超过阈值，就认为两个单词之间具有语义关系。然后根据单词之间语义关系出现的频率计算结点之间的边权值。</p><p>2）Syntactic-based graph。使用Stanford CoreNLP解析器来提取单词之间的依赖关系。虽然提取的依赖项是定向的，但为了简单起见，将其视为无定向关系。与Semantic-based graph中使用的策略类似，计算了在整个语料库中每对具有句法依赖的单词的次数，并计算了每对单词的边权重(基于语法的图中的节点)，如图12所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404464738-6c47023b-98b2-4d8a-bc32-f444add73fc5.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7eb37cc5&margin=%5Bobject%20Object%5D&originHeight=186&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7627155e-cf76-4cb9-b033-bfdc18ef5e7&title="><br><strong><em>图12 利用LSTM编码的语义信息建立单词之间的关系。以一份文本为例，基于语义的图是通过收集所有文本语料库中的所有语义关系词对来构建的</em></strong></p><p>3）Sequential-based graph。序列语境描述了局部共现（词与词之间）的语言属性，已被广泛用于文本表示学习。在这项研究中，利用滑动窗口策略和PMI来描述序列语境信息。</p><p>对于graph tensor，所有的图共享相同的节点集，唯一的区别是边。为了将上述三种不同的图聚合在一起，通过池化操作进行权值选取。不过，由于不同权重代表的含义不同，所以不能直接进行简单的池化。引入注意力机制，将分别乘上不同注意力的权值加在一起，代替池化操作：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404529054-6b7314df-996d-45a7-b255-9dd68d1f059d.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=35&id=uf283a3ee&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49f9c114-c9c9-42e9-a462-49d192ddc35&title=&width=517"><br>其中，W是需要学习的注意力矩阵，与邻接矩阵A的size相同。TensorGCN的图内传播和图间传播学习过程如图13：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404555876-429c3774-b6ff-467f-bc22-cb15abbea76b.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a5b49aa&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc8c91245-a4eb-4f26-9fe0-20afcd23103&title="><br><strong><em>图13 以具有三个单词节点和三个文档节点的文本图张量为例，展示TensorGCN学习过程中的一个层。(a)图内传播从输入图张量学习；（b）图间传播学习，使用图内传播的输出作为其输入。这里仅以一个虚拟图为例，说明如何通过图间传播学习来协调异质信息。在实践中，所有的虚拟图都必须进行图间传播学习</em></strong><br>图内传播就是在三种不同的图的内部分别进行GCN的卷积操作：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404623366-db22445a-7d56-4fff-a514-75666f5a4d61.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=41&id=u9e6a632c&margin=%5Bobject%20Object%5D&originHeight=68&originWidth=770&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf8ed1386-9d50-4e69-b595-bb222802669&title=&width=469"><br> 图间传播学习在不同的graph之间交换信息（图13 b），为此定义了一系列特殊的图，称为virtual graph，通过连接张量中所有图的节点来实现，每一个结点都产生一个r*r大小的虚图，最终得到了图间邻接矩阵的tensor。每个虚结点之间都有边，并且权重设置为1。虚拟图上的图间信息传播学习定义如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1665404648284-daef4e88-62c1-4a9c-9911-8856c4009448.png#clientId=u5870d980-5fcc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=49&id=ueee598da&margin=%5Bobject%20Object%5D&originHeight=74&originWidth=860&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc0e6f8f8-a3ed-4ab7-9d35-5f1f5240302&title=&width=572"><br>在TensorGCN的最后一层，在完成图间传播之后，对图执行一个平均池，以获得用于分类的文档节点的最终表示。</p><table><thead><tr><th>TensorGCN</th><th><a href="https://sota.jiqizhixin.com/models/models/2702592d-f69f-41a6-9c29-924999576bd3">https://sota.jiqizhixin.com/models/models/2702592d-f69f-41a6-9c29-924999576bd3</a></th></tr></thead></table>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言历史</title>
      <link href="/2022/10/10/go%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2/"/>
      <url>/2022/10/10/go%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="🏆-Go语言的Logo"><a href="#🏆-Go语言的Logo" class="headerlink" title="🏆 Go语言的Logo"></a>🏆 Go语言的Logo</h2><p>作为程序员，我们每天会用到大量的编程语言，打开界面会碰到很多logo，在正式学习Go语言之前，我们先来了解一下Go语言的Logo。也就是它,下面这个动物，gopher [ˈɡoʊfər] ，囊地鼠，是北美的一种地鼠。也有人说这是土拨鼠，大家自行理解吧。</p><blockquote><p>故事</p></blockquote><p>Rob Pike是Go的发明者之一，贝尔实验室UNIX小组成员之一，UTF-8的设计人。他最喜欢做似乎就是：</p><ul><li><p>发明操作系统</p></li><li><p>发明编辑器</p></li><li><p>发明语言</p></li></ul><p>Go语言这萌萌的吉祥物是由Rob Pike的妻子 Renee French绘制的，golang吉祥物的设计者Renee French是一位知名插画师，她的画风是这样的：就是她设计出了Golang吉祥物，可爱的 Gordon [ˈgɔrdən]比心心！</p><h2 id="🍀-谷歌工程师的20-时间"><a href="#🍀-谷歌工程师的20-时间" class="headerlink" title="🍀 谷歌工程师的20%时间"></a>🍀 谷歌工程师的20%时间</h2><p>谷歌的“20%时间”工作方式，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务Google Now、谷歌新闻Google News、谷歌地图Google Map上的交通信息等，全都是20%时间的产物。Go语言最开始也是20%时间的产物。</p><blockquote><p>为什么需要一个新的语言</p></blockquote><p>最近十年来，C&#x2F;C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了。传统的语言比如c++，大家花费太多时间来学习如何使用这门语言，而不是如何更好的表达写作者的思想，同时编译花费的时间实在太长，对于编写-编译-运行这个链条来说周期太长。动态语言如Python，由于没有强类型的约束，很多问题需要在运行时发现，这种低级错误更应该交给编译器来发现。人力成本越来越高机器越来越便宜机器的性能越来越厉害在开发效率和运行速度上达到平衡go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。这个世界上总有一帮人在想着做这种事情，别人的用的不舒服，就自己开发了一个！</p><h2 id="🍀-Go语言的创始人"><a href="#🍀-Go语言的创始人" class="headerlink" title="🍀 Go语言的创始人"></a>🍀 Go语言的创始人</h2><p>Go的三个作者分别是：Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默） 。Rob Pike：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。他与Thompson共事多年，并共创出广泛使用的UTF-8 字元编码。Ken Thompson：主要是B语言、C语言的作者、Unix之父。1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言。Robert Griesemer：在开发Go之前是Google V8、Chubby和HotSpot JVM的主要贡献者。此外还有Plan 9开发者Russ Cox、和曾改善目前广泛使用之开原码编译器GCC的Ian Taylor。</p><h2 id="🥦-Go语言的发展"><a href="#🥦-Go语言的发展" class="headerlink" title="🥦 Go语言的发展"></a>🥦 Go语言的发展</h2><blockquote><p>故事一：名字的来源</p></blockquote><p>这是一封由 Rob Pike 在 2007 年 9 月 25 号，星期二，下午 3：12 回复给 Robert Griesemer、Ken Thompson 的有关编程语言讨论主题的邮件。邮件正文大意为：在开车回家的路上我得到了些灵感，给这门编程语言取名为“go”，它很简短，易书写。工具类可以命名为：goc、 gol、goa。交互式的调试工具也可以直接命名为“go”。语言文件后缀名为 .go 等等这就是 Go 语言名字的来源。自此之后 Robert、Rob 和 Ken 三个人开始在 Google 内部进行了研发，一直到了 2009 年，Go 正式开源了。Go 项目团队将 2009 年 11 月 10 日，即该语言正式对外开源的日子作为其官方生日。源代码最初托管在 <a href="http://code.google.com/">http://code.google.com</a> 上，之后几年才逐步的迁移到 GitHub 上。</p><blockquote><p>故事二：新伙伴的加入</p></blockquote><p>这是一封由 Ian Lance Taylor 在 2008 年 6月 7 日（星期六）的晚上 7：06 写给 Robert Griesemer、Rob Pike、 Ken Thompson 的关于 Go gcc 编译器前端的邮件。邮件正文大意如下：我的同事向我推荐了这个网站 http:&#x2F;&#x2F;…&#x2F;go_lang.html 。这似乎是一门很有趣的编程语言。我为它写了一个 gcc 编译器前端。虽然这个工具仍缺少很多的功能，但它确实可以编译网站上展示的那个素数筛选程序了。Ian Lance Taylor 的加入以及第二个编译器 (gcc go) 的实现 在带来震惊的同时，也伴随着喜悦。这对 Go 项目来说不仅仅是鼓励，更是一种对可行性的证明。语言的第二次实现对制定语言规范和确定标准库的过程至关重要，同时也有助于保证其高可移植性，这也是 Go 语言承诺的一部分。自此之后 Ian Lance Taylor 成为了设计和实现 Go 语言及其工具的核心人物。</p><blockquote><p>故事三：http.HandlerFunc、I&#x2F;O 库</p></blockquote><p>Russ Cox 在2008年带着他的语言设计天赋和编程技巧加入了刚成立不久的 Go 团队。Russ 发现 Go 方法的通用性意味着函数也能拥有自己的方法，这直接促成了 http.HandlerFunc 的实现，这是一个让 Go 一下子变得无限可能的特性。Russ 还提出了更多的泛化性的想法，比如 io.Reader 和 io.Writer 接口，奠定了所有 I&#x2F;O 库的整体结构。</p><blockquote><p>故事四：cryptographic</p></blockquote><p>安全专家 Adam Langley 帮助 Go 走向 Google 外面的世界。Adam 为 Go 团队做了许多不为外人知晓的工作，包括创建最初的 <a href="http://golang.org/">http://golang.org</a> 网站以及 build dashboard。不过他最大的贡献当属创建了 cryptographic 库。起先，在我们中的部分人看来，这个库无论在规模还是复杂度上都不成气候。但是就是这个库在后期成为了很多重要的网络和安全软件的基础，并且成为了 Go 语言开发历史的关键组成部分。许多网络基础设施公司，比如 Cloudflare，均重度依赖 Adam 在 Go 项目上的工作，互联网也因它变得更好。我记得当初 beego 设计的时候，session 模块设计的时候也得到了 Adam 的很多建议，因此，就 Go 而言，我们由衷地感谢 Adam。</p><blockquote><p>时间线小结</p></blockquote><ul><li><p>2007年9月，Rob Pike在Google分布式编译平台上进行C++编译，在漫长的等待过程中，他和Robert Griesemer探讨了程序设计语言的一些关键性问题，他们认为，简化编程语言相比于在臃肿的语言上不断增加新特性，会是更大的进步。随后他们在编译结束之前说服了身边的Ken Thompson，觉得有必要为此做一些事情。几天后，他们发起了一个叫Golang的项目，将它作为自由时间的实验项目。</p></li><li><p>2008年5月 Google发现了GO语言的巨大潜力，得到了Google的全力支持，这些人开始全职投入GO语言的设计和开发。</p></li><li><p>2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。</p></li><li><p>2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。</p></li></ul><p>在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。</p><blockquote><p>故事五：Docker、Kubernetes。</p></blockquote><p>一家叫做 Docker 的公司。就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目，如etcd&#x2F;consul&#x2F;flannel，七牛云存储等等 均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p><blockquote><p>展望</p></blockquote><p>Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C &#x2F; C++代码的速度，而且更加安全、支持并行进程。作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。</p><h2 id="🥦-使用Go语言的项目"><a href="#🥦-使用Go语言的项目" class="headerlink" title="🥦 使用Go语言的项目"></a>🥦 使用Go语言的项目</h2><p>下面列举的是原生使用Go语言进行开发的部分项目。</p><blockquote><p>Docker</p></blockquote><p>Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。项目链接：<a href="https://github.com/docker/docker">https://github.com/docker/docker</a></p><blockquote><p>Go语言</p></blockquote><p>Go语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。Go语言的源码对了解Go语言的底层调度有极大的参考意义，建议希望对Go语言有深入了解的读者读一读。项目链接：<a href="https://github.com/golang/go">https://github.com/golang/go</a></p><blockquote><p>Kubernetes</p></blockquote><p>Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod（容器仓）。项目链接：<a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p><blockquote><p>etcd</p></blockquote><p>一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用Go语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。项目链接：<a href="https://github.com/coreos/etcd">https://github.com/coreos/etcd</a></p><blockquote><p>beego</p></blockquote><p>beego 是一个类似 Python 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。项目链接：<a href="https://github.com/astaxie/beego">https://github.com/astaxie/beego</a></p><blockquote><p>martini</p></blockquote><p>一款快速构建模块化的 Web 应用的Go语言框架。项目链接：<a href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a></p><blockquote><p>codis</p></blockquote><p>国产的优秀分布式 Redis 解决方案。可以将 codis 理解成为 Web 服务领域的 Nginx，它实现了对 Redis 的反向代理和负载均衡。项目链接：<a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p><blockquote><p>delve</p></blockquote><p>Go语言强大的调试器，被很多集成环境和编辑器整合。项目链接：<a href="https://github.com/derekparker/delve">https://github.com/derekparker/delve</a></p><h2 id="🥦-哪些大公司在用"><a href="#🥦-哪些大公司在用" class="headerlink" title="🥦 哪些大公司在用"></a>🥦 哪些大公司在用</h2><p>Go语言是谷歌在 2009 年发布的一款编程语言，自面世以来它以高效的开发效率和完美的运行速度迅速风靡全球，被誉为“21 世纪的C语言”。现在越来越多的公司开始使用Go语言开发自己的服务，同时也诞生了很多使用Go语言开发的服务和应用，比如 Docker、k8s 等，下面我们来看一下，有哪些大公司在使用Go语言。</p><blockquote><p>Google</p></blockquote><p>作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《哪些项目使用Go语言开发》一节了解更多的Go语言开源项目。</p><blockquote><p>Facebook</p></blockquote><p>Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 <a href="https://github.com/facebookgo">https://github.com/facebookgo</a> 访问查看 facebook 开源的项目，其中最具代表性的就是著名平滑重启工具 grace。</p><blockquote><p>腾讯</p></blockquote><p>腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C&#x2F;C++ ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C&#x2F;C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go。</p><blockquote><p>百度</p></blockquote><p>百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言。</p><blockquote><p>七牛云</p></blockquote><p>七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言。</p><blockquote><p>京东</p></blockquote><p>京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的。</p><blockquote><p>小米</p></blockquote><p>小米对Go语言的支持，在于运维监控系统的开源，它的官方网址是 <a href="http://open-falcon.org/">http://open-falcon.org/</a> 此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言。</p><blockquote><p>360</p></blockquote><p>360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过.<a href="https://github.com/Qihoo360/poseidon">https://github.com/Qihoo360/poseidon</a> 查看，还有 360 的推送团队也在使用Go语言。除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。Go语言的强项在于它适合用来开发网络并发方面的服务，比如消息推送、监控、容器等，所以在高并发的项目上大多数公司会优先选择 Golang 作为开发语言。</p><h2 id="🍊-Go语言代码清爽"><a href="#🍊-Go语言代码清爽" class="headerlink" title="🍊 Go语言代码清爽"></a>🍊 Go语言代码清爽</h2><p>Go语言语法类似于C语言，因此熟悉C语言及其派生语言（[C++]、[C#]、Objective-C 等）的人都会迅速熟悉这门语言。C语言的有些语法会让代码可读性降低甚至发生歧义。Go语言在C语言的基础上取其精华，弃其糟粕，将C语言中较为容易发生错误的写法进行调整，做出相应的编译提示。</p><blockquote><p>去掉循环冗余括号</p></blockquote><p>Go语言在众多大师的丰富实战经验的基础上诞生，去除了C语言语法中一些冗余、烦琐的部分。下面的代码是C语言的数值循环：</p><ol><li><p><code>// C语言的for数值循环</code></p></li><li><p><code>for(int a =0;a&lt;10;a++)&#123;</code></p></li><li><p><code>// 循环代码</code></p></li><li><p><code>&#125;</code></p></li></ol><p>在Go语言中，这样的循环变为：</p><ol><li><p><code>for a :=0;a&lt;10;a++&#123;</code></p></li><li><p><code>// 循环代码</code></p></li><li><p><code>&#125;</code></p></li></ol><p>for 两边的括号被去掉，int 声明被简化为<code>:=</code>，直接通过编译器右值推导获得 a 的变量类型并声明。</p><blockquote><p>去掉表达式冗余括号</p></blockquote><p>同样的简化也可以在判断语句中体现出来，以下是C语言的判断语句：</p><ol><li><p><code>if(表达式)&#123;</code></p></li><li><p><code>// 表达式成立</code></p></li><li><p><code>&#125;</code></p></li></ol><p>在Go语言中，无须添加表达式括号，代码如下：</p><ol><li><p><code>if表达式&#123;</code></p></li><li><p><code>// 表达式成立</code></p></li><li><p><code>&#125;</code></p></li></ol><blockquote><p>强制的代码风格</p></blockquote><p>Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。这个特性刚开始会使开发者有一些不习惯，但随着对Go语言的不断熟悉，开发者就会发现风格统一让大家在阅读代码时把注意力集中到了解决问题上，而不是代码风格上。同时Go语言也提供了一套格式化工具。一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。</p><blockquote><p>不再纠结于 i++ 和 ++i</p></blockquote><p>C语言非常经典的考试题为：</p><ol><li><p><code>int a, b;</code></p></li><li><p><code>a = i++;</code></p></li><li><p><code>b =++i;</code></p></li></ol><p>这种题目对于初学者简直摸不着头脑。为什么一个简单的自增表达式需要有两种写法？在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：</p><ol><li><code>i++</code></li></ol><p>如果写成前置自增<code>++i</code>，或者赋值后自增<code>a=i++</code>都将导致编译错误。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><p>总体来说设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="A、创建模式（5种）"><a href="#A、创建模式（5种）" class="headerlink" title="A、创建模式（5种）"></a>A、创建模式（5种）</h1><p><strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></p><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1 工厂模式"></a>1 工厂模式</h2><h3 id="1-1-简单工厂模式"><a href="#1-1-简单工厂模式" class="headerlink" title="1.1 简单工厂模式"></a>1.1 简单工厂模式</h3><p><strong>定义：</strong>定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p><p><strong>举例：</strong>（我们举一个pizza工厂的例子）</p><p>pizza工厂一共生产三种类型的pizza：chesse,pepper,greak。通过工厂类（SimplePizzaFactory）实例化这三种类型的对象。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>工厂类的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SimplePizzaFactory &#123;</span><br><span class="line">       public Pizza CreatePizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new CheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;greek&quot;)) &#123;</span><br><span class="line">                     pizza = new GreekPizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new PepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂存在的问题与解决方法：</strong> 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式。</p><h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h3><p><strong>定义：</strong>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><p><strong>举例：</strong>（我们依然举pizza工厂的例子，不过这个例子中，pizza产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的if else语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦敦工厂。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610872.png"></p><p>OrderPizza中有个抽象的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract Pizza createPizza();</span><br></pre></td></tr></table></figure><p>两个工厂类继承OrderPizza并实现抽象方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LDOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NYOrderPizza extends OrderPizza &#123;</span><br><span class="line"></span><br><span class="line">Pizza createPizza(String ordertype) &#123;</span><br><span class="line">Pizza pizza = null;</span><br><span class="line"></span><br><span class="line">if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">pizza = new NYCheesePizza();</span><br><span class="line">&#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">pizza = new NYPepperPizza();</span><br><span class="line">&#125;</span><br><span class="line">return pizza;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>、通过不同的工厂会得到不同的实例化的对象，PizzaStroe的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new NYOrderPizza();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决了简单工厂模式的问题：</strong>增加一个新的pizza产地（北京），只要增加一个BJOrderPizza类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BJOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个模式的好处就是，如果你现在想增加一个功能，只需做一个实现类就OK了，无需去改动现成的代码。这样做，拓展性较好！</p><p><strong>工厂方法存在的问题与解决方法：</strong>客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p><h3 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h3><p><strong>定义：</strong>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p><p><strong>举例：</strong>（我们依然举pizza工厂的例子，pizza工厂有两个：纽约工厂和伦敦工厂）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>工厂的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbsFactory &#123;</span><br><span class="line">       Pizza CreatePizza(String ordertype) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LDFactory implements AbsFactory &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public Pizza CreatePizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (&quot;cheese&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (&quot;pepper&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PizzaStroe的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new OrderPizza(&quot;London&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决了工厂方法模式的问题：</strong>在抽象工厂中PizzaStroe中只需要传入参数就可以实例化对象。</p><h3 id="1-4-工厂模式适用的场合"><a href="#1-4-工厂模式适用的场合" class="headerlink" title="1.4 工厂模式适用的场合"></a>1.4 工厂模式适用的场合</h3><p>大量的产品需要创建，并且这些产品具有共同的接口 。</p><h3 id="1-5-三种工厂模式的使用选择"><a href="#1-5-三种工厂模式的使用选择" class="headerlink" title="1.5 三种工厂模式的使用选择"></a>1.5 三种工厂模式的使用选择</h3><p>简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p><p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p><p>抽象工厂 ：用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）</p><p><strong>简单工厂的适用场合：</strong>只有伦敦工厂（只有这一个等级），并且这个工厂只生产三种类型的pizza：chesse,pepper,greak（固定产品）。</p><p><strong>工厂方法的适用场合</strong>：现在不光有伦敦工厂，还增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂依然只生产三种类型的pizza：chesse,pepper,greak（固定产品）。</p><p><strong>抽象工厂的适用场合：</strong>不光增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂还增加了一种新的类型的pizza：chinese pizza（增加产品族）。</p><p><strong>所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。</strong>因此，我们可以用抽象工厂模式创建工厂，而用工厂方法模式创建生产线。比如，我们可以使用抽象工厂模式创建伦敦工厂和纽约工厂，使用工厂方法实现cheese pizza和greak pizza的生产。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>总结一下三种模式：</p><p><strong>简单工厂模式就是建立一个实例化对象的类，在该类中对多个对象实例化。工厂方法模式是定义了一个创建对象的抽象方法，由子类决定要实例化的类。这样做的好处是再有新的类型的对象需要实例化只要增加子类即可。抽象工厂模式定义了一个接口用于创建对象族，而无需明确指定具体类。抽象工厂也是把对象的实例化交给了子类，即支持拓展。同时提供给客户端接口，避免了用户直接操作子类工厂。</strong></p><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2 单例模式"></a>2 单例模式</h2><p><strong>定义：</strong>确保一个类最多只有一个实例，并提供一个全局访问点</p><p>单例模式可以分为两种：预加载和懒加载</p><h3 id="2-1-预加载"><a href="#2-1-预加载" class="headerlink" title="2.1 预加载"></a>2.1 预加载</h3><p>顾名思义，就是预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PreloadSingleton &#123;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton instance = new PreloadSingleton();</span><br><span class="line">   </span><br><span class="line">       //其他的类无法实例化单例类的对象</span><br><span class="line">       private PreloadSingleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton getInstance() &#123;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>很明显，没有使用该单例对象，该对象就被加载到了内存，会造成内存的浪费。</strong></p><h3 id="2-2-懒加载"><a href="#2-2-懒加载" class="headerlink" title="2.2 懒加载"></a>2.2 懒加载</h3><p>为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       </span><br><span class="line">       private static Singleton instance=null;</span><br><span class="line">       </span><br><span class="line">       private Singleton()&#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static Singleton getInstance()</span><br><span class="line">       &#123;</span><br><span class="line">              if(instance==null)</span><br><span class="line">              &#123;</span><br><span class="line">                     instance=new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-单例模式和线程安全"><a href="#2-3-单例模式和线程安全" class="headerlink" title="2.3 单例模式和线程安全"></a>2.3 单例模式和线程安全</h3><p>（1）预加载只有一条语句return instance,这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。</p><p>（2）懒加载不浪费内存，但是无法保证线程的安全。首先，if判断以及其内存执行代码是非原子性的。其次，new Singleton()无法保证执行的顺序性。</p><p>不满足原子性或者顺序性，线程肯定是不安全的，这是基本的常识，不再赘述。我主要讲一下为什么new Singleton()无法保证顺序性。我们知道创建一个对象分三步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();//1:初始化内存空间</span><br><span class="line"></span><br><span class="line">ctorInstance(memory);//2:初始化对象</span><br><span class="line"></span><br><span class="line">instance=memory();//3:设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure><p><strong>jvm为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面2和3行代码可能被重新排序。</strong>我们用两个线程来说明线程是不安全的。线程A和线程B都创建对象。其中，A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象（线程不安全）。</p><p><img src="https://img-blog.csdnimg.cn/20190609030328860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><h3 id="2-4-保证懒加载的线程安全"><a href="#2-4-保证懒加载的线程安全" class="headerlink" title="2.4 保证懒加载的线程安全"></a>2.4 保证懒加载的线程安全</h3><p>我们首先想到的就是使用synchronized关键字。synchronized加载getInstace()函数上确实保证了线程的安全。但是，如果要经常的调用getInstance()方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用synchronized加锁，直接返回对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     instance = new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把sychronized加在if(instance&#x3D;&#x3D;null)判断语句里面，<strong>保证instance未实例化的时候才加锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (Singleton.class) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经过2.3的讨论知道new一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字volatile保证对象实例化过程的顺序性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static volatile Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (instance) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>到此，我们就保证了懒加载的线程安全。</strong></p><h2 id="3-生成器模式"><a href="#3-生成器模式" class="headerlink" title="3 生成器模式"></a>3 生成器模式</h2><p><strong>定义：</strong>封装一个复杂对象构造过程，并允许按步骤构造。</p><p><strong>定义解释：</strong> 我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。</p><h3 id="3-1-模式的结构和代码示例"><a href="#3-1-模式的结构和代码示例" class="headerlink" title="3.1 模式的结构和代码示例"></a>3.1 模式的结构和代码示例</h3><p>生成器模式结构中包括四种角色：</p><p>（1）产品(Product)：具体生产器要构造的复杂对象；</p><p>（2）抽象生成器(Bulider)：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（<strong>定义构造步骤</strong>）；</p><p>（3）具体生产器(ConcreteBuilder)：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法（<strong>生产各个组件</strong>）；</p><p>（4）指挥者(Director)：指挥者是一个类，该类需要含有Builder接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。（<strong>按照步骤组装部件，并返回Product</strong>）</p><p><img src="https://img-blog.csdnimg.cn/20190609172340456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p><strong>举例</strong>（我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标）</p><p>虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609172340477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>ComputerBuilder类定义构造步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ComputerBuilder &#123;</span><br><span class="line">   </span><br><span class="line">    protected Computer computer;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computer;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void buildComputer() &#123;</span><br><span class="line">        computer = new Computer();</span><br><span class="line">        System.out.println(&quot;生成了一台电脑！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void buildMaster();</span><br><span class="line">    public abstract void buildScreen();</span><br><span class="line">    public abstract void buildKeyboard();</span><br><span class="line">    public abstract void buildMouse();</span><br><span class="line">    public abstract void buildAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HPComputerBuilder定义各个组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HPComputerBuilder extends ComputerBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMaster() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMaster(&quot;i7,16g,512SSD,1060&quot;);</span><br><span class="line">        System.out.println(&quot;(i7,16g,512SSD,1060)的惠普主机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildScreen() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setScreen(&quot;1080p&quot;);</span><br><span class="line">        System.out.println(&quot;(1080p)的惠普显示屏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildKeyboard() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setKeyboard(&quot;cherry 青轴机械键盘&quot;);</span><br><span class="line">        System.out.println(&quot;(cherry 青轴机械键盘)的键盘&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMouse() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMouse(&quot;MI 鼠标&quot;);</span><br><span class="line">        System.out.println(&quot;(MI 鼠标)的鼠标&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildAudio() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setAudio(&quot;飞利浦 音响&quot;);</span><br><span class="line">        System.out.println(&quot;(飞利浦 音响)的音响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director类对组件进行组装并生成产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line">   </span><br><span class="line">    private ComputerBuilder computerBuilder;</span><br><span class="line">    public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;</span><br><span class="line">        this.computerBuilder = computerBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computerBuilder.getComputer();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void constructComputer() &#123;</span><br><span class="line">        computerBuilder.buildComputer();</span><br><span class="line">        computerBuilder.buildMaster();</span><br><span class="line">        computerBuilder.buildScreen();</span><br><span class="line">        computerBuilder.buildKeyboard();</span><br><span class="line">        computerBuilder.buildMouse();</span><br><span class="line">        computerBuilder.buildAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-生成器模式的优缺点"><a href="#3-2-生成器模式的优缺点" class="headerlink" title="3.2 生成器模式的优缺点"></a>3.2 生成器模式的优缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>将一个对象分解为各个组件</p></li><li><p>将对象组件的构造封装起来</p></li><li><p>可以控制整个对象的生成过程</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量</li></ul><h3 id="3-3-生成器模式与工厂模式的不同"><a href="#3-3-生成器模式与工厂模式的不同" class="headerlink" title="3.3 生成器模式与工厂模式的不同"></a>3.3 生成器模式与工厂模式的不同</h3><p>生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。</p><h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4 原型模式"></a>4 原型模式</h2><p><strong>定义：</strong>通过复制现有实例来创建新的实例，无需知道相应类的信息。</p><p>简单地理解，其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会clone一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：<strong>Clone</strong>。</p><h3 id="4-1-深拷贝和浅拷贝"><a href="#4-1-深拷贝和浅拷贝" class="headerlink" title="4.1 深拷贝和浅拷贝"></a>4.1 深拷贝和浅拷贝</h3><p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p><p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p><h3 id="4-2-原型模式的结构和代码示例"><a href="#4-2-原型模式的结构和代码示例" class="headerlink" title="4.2 原型模式的结构和代码示例"></a>4.2 原型模式的结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190609184856243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>Client：使用者</p><p>Prototype：接口（抽象类），声明具备clone能力，例如java中得Cloneable接口</p><p>ConcretePrototype：具体的原型类</p><p>可以看出设计模式还是比较简单的，重点在于Prototype接口和Prototype接口的实现类ConcretePrototype。原型模式的具体实现：一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable &#123;  </span><br><span class="line">     public Object clone() throws CloneNotSupportedException &#123;  </span><br><span class="line">         Prototype proto = (Prototype) super.clone();  </span><br><span class="line">         return proto;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>举例（</strong>银行发送大量邮件，使用clone和不使用clone的时间对比<strong>）：</strong>我们模拟创建一个对象需要耗费比较长的时间，因此，在构造函数中我们让当前线程sleep一会</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Mail(EventTemplate et) &#123;</span><br><span class="line">              this.tail = et.geteventContent();</span><br><span class="line">              this.subject = et.geteventSubject();</span><br><span class="line">              try &#123;</span><br><span class="line">                     Thread.sleep(1000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                     // TODO Auto-generated catch block</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>不使用clone,发送十个邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">              int i = 0;</span><br><span class="line">              int MAX_COUNT = 10;</span><br><span class="line">              EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">              long start = System.currentTimeMillis();</span><br><span class="line">              while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                     // 以下是每封邮件不同的地方</span><br><span class="line">                     Mail mail = new Mail(et);</span><br><span class="line">                     mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot; + mail.getTail());</span><br><span class="line">                     mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                     // 然后发送邮件</span><br><span class="line">                     sendMail(mail);</span><br><span class="line">                     i++;</span><br><span class="line">              &#125;</span><br><span class="line">              long end = System.currentTimeMillis();</span><br><span class="line">              System.out.println(&quot;用时:&quot; + (end - start));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>用时：10001</strong></p><p>使用clone,发送十个邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">          int i = 0;</span><br><span class="line">          int MAX_COUNT = 10;</span><br><span class="line">          EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">          long start=System.currentTimeMillis();</span><br><span class="line">          Mail mail = new Mail(et);         </span><br><span class="line">          while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                 Mail cloneMail = mail.clone();</span><br><span class="line">                 mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot;</span><br><span class="line">                              + mail.getTail());</span><br><span class="line">                 mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                 sendMail(cloneMail);</span><br><span class="line">                 i++;</span><br><span class="line">          &#125;</span><br><span class="line">          long end=System.currentTimeMillis();</span><br><span class="line">          System.out.println(&quot;用时:&quot;+(end-start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>用时：1001</strong></p><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p><strong>原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。</strong></p><h1 id="B、结构模式（7种）"><a href="#B、结构模式（7种）" class="headerlink" title="B、结构模式（7种）"></a>B、结构模式（7种）</h1><p>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5 适配器模式"></a>5 适配器模式</h2><p><strong>定义：</strong> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p><p><strong>主要分为三类：</strong>类的适配器模式、对象的适配器模式、接口的适配器模式。</p><h3 id="5-1-类适配器模式"><a href="#5-1-类适配器模式" class="headerlink" title="5.1 类适配器模式"></a>5.1 类适配器模式</h3><p>通过多重<strong>继承</strong>目标接口和被适配者类方式来实现适配</p><p><strong>举例</strong>(将USB接口转为VGA接口)，类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609210401275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>USBImpl的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class USBImpl implements USB&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void showPPT() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              System.out.println(&quot;PPT内容演示&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdatperUSB2VGA 首先继承USBImpl获取USB的功能，其次，实现VGA接口，表示该类的类型为VGA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA extends USBImpl implements VGA &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Projector将USB映射为VGA，只有VGA接口才可以连接上投影仪进行投影</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Projector&lt;T&gt; &#123;</span><br><span class="line">       public void projection(T t) &#123;</span><br><span class="line">              if (t instanceof VGA) &#123;</span><br><span class="line">                     System.out.println(&quot;开始投影&quot;);</span><br><span class="line">                     VGA v = new VGAImpl();</span><br><span class="line">                     v = (VGA) t;</span><br><span class="line">                     v.projection();</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                     System.out.println(&quot;接口不匹配，无法投影&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">       //通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法</span><br><span class="line">       VGA a=new AdapterUSB2VGA();</span><br><span class="line">       //进行投影</span><br><span class="line">       Projector p1=new Projector();</span><br><span class="line">       p1.projection(a);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="5-2-对象适配器模式"><a href="#5-2-对象适配器模式" class="headerlink" title="5.2 对象适配器模式"></a>5.2 对象适配器模式</h3><p>对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。</p><p><strong>举例</strong>(将USB接口转为VGA接口)，类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609210401318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现VGA接口，表示适配器类是VGA类型的，适配器方法中直接使用USB对象。</p><h3 id="5-3-接口适配器模式"><a href="#5-3-接口适配器模式" class="headerlink" title="5.3 接口适配器模式"></a>5.3 接口适配器模式</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，<strong>它适用于一个接口不想使用其所有的方法的情况。</strong></p><p><strong>举例</strong>(将USB接口转为VGA接口，VGA中的b()和c()不会被实现)，类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609210401289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>AdapterUSB2VGA抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void b() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public void c() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdapterUSB2VGA实现，不用去实现b()和c()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGAImpl extends AdapterUSB2VGA &#123;</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.projection();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h3><p>总结一下三种适配器模式的应用场景：</p><p><strong>类适配器模式：</strong>当希望将<strong>一个类</strong>转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p><p><strong>对象适配器模式：</strong>当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p><p><strong>接口适配器模式：</strong>当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p><p><strong>命名规则：</strong></p><p><strong>我个人理解，三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</strong></p><p>类适配器，以类给到，在Adapter里，就是将src当做类，继承，</p><p>对象适配器，以对象给到，在Adapter里，将src作为一个对象，持有。</p><p>接口适配器，以接口给到，在Adapter里，将src作为一个接口，实现。</p><p><strong>使用选择：</strong></p><p><strong>根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。</strong></p><h2 id="6-装饰者模式"><a href="#6-装饰者模式" class="headerlink" title="6 装饰者模式"></a>6 装饰者模式</h2><p><strong>定义：</strong>动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。</p><h3 id="6-1-装饰者模式结构图与代码示例"><a href="#6-1-装饰者模式结构图与代码示例" class="headerlink" title="6.1 装饰者模式结构图与代码示例"></a>6.1 装饰者模式结构图与代码示例</h3><p>1.Component（被装饰对象的基类）</p><p>定义一个对象接口，可以给这些对象动态地添加职责。</p><p>2.ConcreteComponent（具体被装饰对象）</p><p>定义一个对象，可以给这个对象添加一些职责。</p><p>3.Decorator（装饰者抽象类）</p><p>维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</p><p>4.ConcreteDecorator（具体装饰者）</p><p>具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</p><p><strong>被装饰对象和修饰者继承自同一个超类</strong></p><p><img src="https://img-blog.csdnimg.cn/20190609223457210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p><strong>举例</strong>(咖啡馆订单项目：1）、咖啡种类：Espresso、ShortBlack、LongBlack、Decaf2）、<strong>调料（装饰者）</strong>：Milk、Soy、Chocolate)，类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609222716270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>被装饰的对象和装饰者都继承自同一个超类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Drink &#123;</span><br><span class="line">       public String description=&quot;&quot;;</span><br><span class="line">       private float price=0f;;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       public void setDescription(String description)</span><br><span class="line">       &#123;</span><br><span class="line">              this.description=description;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public String getDescription()</span><br><span class="line">       &#123;</span><br><span class="line">              return description+&quot;-&quot;+this.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       public float getPrice()</span><br><span class="line">       &#123;</span><br><span class="line">              return price;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setPrice(float price)</span><br><span class="line">       &#123;</span><br><span class="line">              this.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">       public abstract float cost();</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被装饰的对象，不用去改造。原来怎么样写，现在还是怎么写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  class Coffee extends Drink &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coffee类的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Decaf extends Coffee &#123;</span><br><span class="line">       public Decaf()</span><br><span class="line">       &#123;</span><br><span class="line">              super.setDescription(&quot;Decaf&quot;);</span><br><span class="line">              super.setPrice(3.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者</p><p>装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为coffee+milk。再加牛奶价格为coffee+milk+chocolate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Decorator extends Drink &#123;</span><br><span class="line">       private Drink Obj;</span><br><span class="line">       public Decorator(Drink Obj) &#123;</span><br><span class="line">              this.Obj = Obj;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice() + Obj.cost();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public String getDescription() &#123;</span><br><span class="line">              return super.description + &quot;-&quot; + super.getPrice() + &quot;&amp;&amp;&quot; + Obj.getDescription();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者实例化（加牛奶）。这里面要对被修饰的对象进行实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Milk extends Decorator &#123;</span><br><span class="line">       public Milk(Drink Obj) &#123;          </span><br><span class="line">              super(Obj);</span><br><span class="line">              // TODO Auto-generated constructor stub</span><br><span class="line">              super.setDescription(&quot;Milk&quot;);</span><br><span class="line">              super.setPrice(2.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coffee店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeBar &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              Drink order;</span><br><span class="line">              order = new Decaf();</span><br><span class="line">              System.out.println(&quot;order1 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order1 desc:&quot; + order.getDescription());</span><br><span class="line">              System.out.println(&quot;****************&quot;);</span><br><span class="line">              order = new LongBlack();</span><br><span class="line">              order = new Milk(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              System.out.println(&quot;order2 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order2 desc:&quot; + order.getDescription());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.2 总结</p><p><strong>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。如果是用继承,每当需要增加新的行为时,就要修改原程序了。</strong></p><h2 id="7-代理模式"><a href="#7-代理模式" class="headerlink" title="7 代理模式"></a>7 代理模式</h2><p><strong>定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p><p>举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：</p><p><img src="https://img-blog.csdnimg.cn/2019061001123986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><h3 id="7-1-为什么要用代理模式？"><a href="#7-1-为什么要用代理模式？" class="headerlink" title="7.1 为什么要用代理模式？"></a>7.1 为什么要用代理模式？</h3><p><strong>中介隔离作用：</strong>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</p><p><strong>开闭原则，增加功能：</strong>代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</p><p><strong>代理模式分为三类：1. 静态代理 2. 动态代理 3. CGLIB代理</strong></p><p>7.2 静态代理</p><p><strong>举例</strong>(买房），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/2019061001123984.png"></p><p>第一步：创建服务类接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BuyHouse &#123;</span><br><span class="line">    void buyHosue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：实现服务接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseImpl implements BuyHouse &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;我要买房&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：创建代理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseProxy implements BuyHouse &#123;</span><br><span class="line">       private BuyHouse buyHouse;</span><br><span class="line">       public BuyHouseProxy(final BuyHouse buyHouse) &#123;</span><br><span class="line">              this.buyHouse = buyHouse;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              buyHouse.buyHosue();</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p><p>缺点： <strong>代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，工作量太大</strong>，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p><h3 id="7-3-动态代理"><a href="#7-3-动态代理" class="headerlink" title="7.3 动态代理"></a>7.3 动态代理</h3><p>动态代理有以下特点:</p><p>1.代理对象,不需要实现接口</p><p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象&#x2F;目标对象实现的接口的类型)</p><p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p><p><strong>动态代理实现：</strong></p><p>Java.lang.reflect.Proxy类可以直接生成一个代理对象</p><ul><li><p>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)生成一个代理对象</p><ul><li><p>参数1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器</p></li><li><p>参数2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口</p></li><li><p>参数3:InvocationHandler h (接口)执行处理类</p></li></ul></li><li><p>InvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：调用代理类的任何方法，此方法都会执行</p><ul><li><p>参数3.1:代理对象(慎用)</p></li><li><p>参数3.2:当前执行的方法</p></li><li><p>参数3.3:当前执行的方法运行时传递过来的参数</p></li></ul></li></ul><p>第一步：编写动态处理器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">       private Object object;</span><br><span class="line">       public DynamicProxyHandler(final Object object) &#123;</span><br><span class="line">              this.object = object;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              Object result = method.invoke(object, args);</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">              return result;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：编写测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new</span><br><span class="line">                Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理总结：</strong>虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏（我们要使用被代理的对象的接口），因为它的设计注定了这个遗憾。</p><p>7.4 CGLIB代理</p><p><strong>CGLIB 原理</strong>：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。</p><p><strong>CGLIB 底层</strong>：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p><p><strong>CGLIB缺点</strong>：对于final方法，无法进行代理。</p><p>CGLIB的实现步骤：</p><p>第一步：建立拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line"></span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数：Object为由CGLib动态生成的代理类实例，Method为上文中实体类所调用的被代理的方法引用，Object[]为参数值列表，MethodProxy为生成的代理类对方法的代理引用。</p><p>返回：从代理实例的方法调用返回的值。</p><p>其中，<strong>proxy.invokeSuper(obj,arg)</strong> 调用代理类实例上的proxy方法的父类方法（即实体类TargetObject中对应的方法）</p><p>第二步： 生成动态代理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;</span><br><span class="line">    public Object getInstance(final Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。</p><p>首先将被代理类TargetObject设置成父类，然后设置拦截器TargetInterceptor，最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型TargetObject。</p><p>第三步：测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        CglibProxy cglibProxy = new CglibProxy();</span><br><span class="line">        BuyHouseImpl buyHouseCglibProxy = (BuyHouseImpl) cglibProxy.getInstance(buyHouse);</span><br><span class="line">        buyHouseCglibProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB代理总结： <strong>CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</strong></p><h2 id="8-外观模式"><a href="#8-外观模式" class="headerlink" title="8 外观模式"></a>8 外观模式</h2><p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p><h3 id="8-1-模式结构和代码示例"><a href="#8-1-模式结构和代码示例" class="headerlink" title="8.1 模式结构和代码示例"></a>8.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190610154828945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到3个角色。</p><p>　　1）.门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（<strong>客户调用，同时自身调用子系统功能</strong>）</p><p>　　2）.子系统角色:实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）</p><p>　　3）.客户角色:通过调用Facede来完成要实现的功能（<strong>调用门面角色</strong>）。</p><p>举例（每个Computer都有CPU、Memory、Disk。在Computer开启和关闭的时候，相应的部件也会开启和关闭），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190610154828952.png"></p><p>首先是子系统类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CPU &#123;</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;cpu is start...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutDown() &#123;</span><br><span class="line">System.out.println(&quot;CPU is shutDown...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Disk &#123;</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Disk is start...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutDown() &#123;</span><br><span class="line">System.out.println(&quot;Disk is shutDown...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memory &#123;</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Memory is start...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutDown() &#123;</span><br><span class="line">System.out.println(&quot;Memory is shutDown...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是，门面类Facade</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">private CPU cpu;</span><br><span class="line">private Memory memory;</span><br><span class="line">private Disk disk;</span><br><span class="line"></span><br><span class="line">public Computer() &#123;</span><br><span class="line">cpu = new CPU();</span><br><span class="line">memory = new Memory();</span><br><span class="line">disk = new Disk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Computer start begin&quot;);</span><br><span class="line">cpu.start();</span><br><span class="line">disk.start();</span><br><span class="line">memory.start();</span><br><span class="line">System.out.println(&quot;Computer start end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shutDown() &#123;</span><br><span class="line">System.out.println(&quot;Computer shutDown begin&quot;);</span><br><span class="line">cpu.shutDown();</span><br><span class="line">disk.shutDown();</span><br><span class="line">memory.shutDown();</span><br><span class="line">System.out.println(&quot;Computer shutDown end...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后为，客户角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Computer computer = new Computer();</span><br><span class="line">computer.start();</span><br><span class="line">System.out.println(&quot;=================&quot;);</span><br><span class="line">computer.shutDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-优点"><a href="#8-2-优点" class="headerlink" title="8.2 优点"></a>8.2 优点</h3><p>　** - 松散耦合**</p><p>　　使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p><p>**　 - 简单易用**</p><p>　　客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</p><p>　** - 更好的划分访问层次**</p><p>　有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p><h2 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9 桥接模式"></a>9 桥接模式</h2><p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><h3 id="9-1-案例"><a href="#9-1-案例" class="headerlink" title="9.1 案例"></a>9.1 案例</h3><p>看下图手机与手机软件的类图</p><p><img src="https://img-blog.csdnimg.cn/20190610180930798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>增加一款新的手机软件，需要在所有手机品牌类下添加对应的手机软件类，当手机软件种类较多时，将导致类的个数急剧膨胀，难以维护</p><p>手机和手机中的软件是什么关系？</p><p>手机中的软件从本质上来说并不是一种手机，手机软件运行在手机中，是一种包含与被包含关系，而不是一种父与子或者说一般与特殊的关系，通过继承手机类实现手机软件类的设计是违反一般规律的。</p><p>如果Oppo手机实现了wifi功能，继承它的Oppo应用商城也会继承wifi功能，并且Oppo手机类的任何变动，都会影响其子类</p><p>换一种解决思路</p><p><img src="https://img-blog.csdnimg.cn/20190610180930823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>从类图上看起来更像是手机软件类图，涉及到手机本身相关的功能，比如说：wifi功能，放到哪个类中实现呢？放到OppoAppStore中实现显然是不合适的</p><p>引起整个结构变化的元素有两个，一个是手机品牌，一个是手机软件，所以我们将这两个点抽出来，分别进行封装</p><p><img src="https://img-blog.csdnimg.cn/20190610180930831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><h3 id="9-2-桥接模式结构和代码示例"><a href="#9-2-桥接模式结构和代码示例" class="headerlink" title="9.2 桥接模式结构和代码示例"></a>9.2 桥接模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190610180930861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p><strong>类图：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190610180930821.png"></p><p><strong>实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Software &#123;</span><br><span class="line">public void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AppStore implements Software &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run app store&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Camera implements Software &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run camera&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Phone &#123;</span><br><span class="line"></span><br><span class="line">protected Software software;</span><br><span class="line"></span><br><span class="line">public void setSoftware(Software software) &#123;</span><br><span class="line">this.software = software;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Oppo extends Phone &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Vivo extends Phone &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比最初的设计，将抽象部分（手机）与它的实现部分（手机软件类）分离，将实现部分抽象成单独的类，使它们都可以独立地变化。整个类图看起来像一座桥，所以称为桥接模式</p><p>继承是一种强耦合关系，子类的实现与它的父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化，因此继承或者说强耦合关系严重影响了类的灵活性，并最终限制了可复用性</p><p>从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互相影响</p><h3 id="9-3-适用场景"><a href="#9-3-适用场景" class="headerlink" title="9.3 适用场景"></a>9.3 适用场景</h3><p>桥接模式通常适用于以下场景。</p><ol><li><p>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</p></li><li><p>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</p></li><li><p>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</p></li></ol><h3 id="9-4-优缺点"><a href="#9-4-优缺点" class="headerlink" title="9.4 优缺点"></a>9.4 优缺点</h3><p><strong>优点：</strong></p><p>(1)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p><p>(2)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</p><p><strong>缺点：</strong></p><p>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p><h2 id="10-组合模式"><a href="#10-组合模式" class="headerlink" title="10 组合模式"></a>10 组合模式</h2><p><strong>定义：</strong>有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p>组合模式的主要优点有：</p><ol><li><p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p></li><li><p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p></li></ol><p>其主要缺点是：</p><ol><li><p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p></li><li><p>不容易限制容器中的构件；</p></li><li><p>不容易用继承的方法来增加构件的新功能；</p></li></ol><h3 id="10-1-模式结构和代码示例"><a href="#10-1-模式结构和代码示例" class="headerlink" title="10.1 模式结构和代码示例"></a>10.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612191511416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ul><li><p>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</p></li><li><p>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</p></li><li><p>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法</p></li></ul><p>举例（访问一颗树），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/201906121917147.png"></p><p>1 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Component &#123;</span><br><span class="line">    public void add(Component c);</span><br><span class="line">    public void remove(Component c);</span><br><span class="line">    public Component getChild(int i);</span><br><span class="line">    public void operation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 叶子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Leaf implements Component&#123;</span><br><span class="line">    </span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Leaf(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void remove(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Component getChild(int i) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"> System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 树枝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Composite implements Component &#123;</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">public void add(Component c) &#123;</span><br><span class="line">children.add(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove(Component c) &#123;</span><br><span class="line">children.remove(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Component getChild(int i) &#123;</span><br><span class="line">return children.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void operation() &#123;</span><br><span class="line">for (Object obj : children) &#123;</span><br><span class="line">((Component) obj).operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11 享元模式"></a>11 享元模式</h2><p><strong>定义：</strong>通过共享的方式高效的支持大量细粒度的对象。</p><p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p><p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p><p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p>简单来说，我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。</p><h3 id="11-1-享元模式的结构图和代码示例"><a href="#11-1-享元模式的结构图和代码示例" class="headerlink" title="11.1 享元模式的结构图和代码示例"></a>11.1 享元模式的结构图和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190610202655697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1、Flyweight (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。</p><p>2、ConcreteFlyweight(具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。</p><p>3、FlyweightFactory(享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成<strong>键值对</strong>，或者其他的存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。</p><p>举例（JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190610202655744.png"></p><p>（1）创建享元对象接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyweight &#123;</span><br><span class="line">    void print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建具体享元对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Flyweight implements IFlyweight &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    public Flyweight(String id)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;Flyweight.id = &quot; + getId() + &quot; ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用HashMap中的key值保证其唯一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    private Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap();</span><br><span class="line">    public IFlyweight getFlyweight(String str)&#123;</span><br><span class="line">        IFlyweight flyweight = flyweightMap.get(str);</span><br><span class="line">        if(flyweight == null)&#123;</span><br><span class="line">            flyweight = new Flyweight(str);</span><br><span class="line">            flyweightMap.put(str, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return  flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getFlyweightMapSize()&#123;</span><br><span class="line">        return flyweightMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）测试，我们创建三个字符串，但是只会产生两个享元对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        FlyweightFactory flyweightFactory = new FlyweightFactory();</span><br><span class="line">        IFlyweight flyweight1 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        IFlyweight flyweight2 = flyweightFactory.getFlyweight(&quot;B&quot;);</span><br><span class="line">        IFlyweight flyweight3 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        flyweight1.print();</span><br><span class="line">        flyweight2.print();</span><br><span class="line">        flyweight3.print();</span><br><span class="line">        System.out.println(flyweightFactory.getFlyweightMapSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190610203118380.png"></p><h1 id="C、关系模式（11种）"><a href="#C、关系模式（11种）" class="headerlink" title="C、关系模式（11种）"></a><strong>C、关系模式（11种）</strong></h1><p>先来张图，看看这11中模式的关系：</p><p>第一类：通过父类与子类的关系进行实现。</p><p>第二类：两个类之间。</p><p>第三类：类的状态。</p><p>第四类：通过中间类</p><p><img src="https://img-blog.csdnimg.cn/20190610215352532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><h2 id="12-策略模式"><a href="#12-策略模式" class="headerlink" title="12 策略模式"></a>12 策略模式</h2><p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码：</strong>实现同一个接口。</p><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><h3 id="12-1-策略模式结构和示例代码"><a href="#12-1-策略模式结构和示例代码" class="headerlink" title="12.1 策略模式结构和示例代码"></a>12.1 策略模式结构和示例代码</h3><p><img src="https://img-blog.csdnimg.cn/20190610215352527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p><strong>抽象策略角色:</strong> 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。</p><p><strong>具体策略角色:</strong> 包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。</p><p><strong>环境角色:</strong> 内部会持有一个抽象角色的引用，给客户端调用。</p><p>举例如下（ 实现一个加减的功能），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190610215352523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1、定义抽象策略角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">public int calc(int num1,int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义具体策略角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calc(int num1, int num2) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class SubstractStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calc(int num1, int num2) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、环境角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">public Environment(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">return strategy.calc(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Environment environment=new Environment(new AddStrategy());</span><br><span class="line">int result=environment.calculate(20, 5);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">Environment environment1=new Environment(new SubstractStrategy());</span><br><span class="line">int result1=environment1.calculate(20, 5);</span><br><span class="line">System.out.println(result1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-模板模式"><a href="#13-模板模式" class="headerlink" title="13 模板模式"></a>13 模板模式</h2><p><strong>定义：</strong>定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。</p><p>通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。</p><h3 id="13-1-模式结构和代码示例"><a href="#13-1-模式结构和代码示例" class="headerlink" title="13.1 模式结构和代码示例"></a>13.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612192139396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>抽象父类（AbstractClass）：实现了模板方法，定义了算法的骨架。</p><p>具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。</p><p>举例（ 我们做菜可以分为三个步骤 （1）备料 （2）具体做菜 （3）盛菜端给客人享用，这三部就是算法的骨架 ；然而做不同菜需要的料，做的方法，以及如何盛装给客人享用都是不同的这个就是不同的实现细节。）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190612192139362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>a. 先来写一个抽象的做菜父类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Dish &#123;    </span><br><span class="line">    /**</span><br><span class="line">     * 具体的整个过程</span><br><span class="line">     */</span><br><span class="line">    protected void dodish()&#123;</span><br><span class="line">        this.preparation();</span><br><span class="line">        this.doing();</span><br><span class="line">        this.carriedDishes();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 备料</span><br><span class="line">     */</span><br><span class="line">    public abstract void preparation();</span><br><span class="line">    /**</span><br><span class="line">     * 做菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void doing();</span><br><span class="line">    /**</span><br><span class="line">     * 上菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void carriedDishes ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 下来做两个番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class EggsWithTomato extends Dish &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void preparation() &#123;</span><br><span class="line">System.out.println(&quot;洗并切西红柿，打鸡蛋。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doing() &#123;</span><br><span class="line">System.out.println(&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void carriedDishes() &#123;</span><br><span class="line">System.out.println(&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Bouilli extends Dish&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preparation() &#123;</span><br><span class="line">        System.out.println(&quot;切猪肉和土豆。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.println(&quot;将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void carriedDishes() &#123;</span><br><span class="line">        System.out.println(&quot;将做好的红烧肉盛进碗里端给客人吃。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 在测试类中我们来做菜：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Dish eggsWithTomato = new EggsWithTomato();</span><br><span class="line">eggsWithTomato.dodish();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line"></span><br><span class="line">Dish bouilli = new Bouilli();</span><br><span class="line">bouilli.dodish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-模板模式的优点和缺点"><a href="#13-2-模板模式的优点和缺点" class="headerlink" title="13.2 模板模式的优点和缺点"></a>13.2 模板模式的优点和缺点</h3><p>优点：</p><p>　（1）具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。</p><p>　（2）代码复用的基本技术，在数据库设计中尤为重要。</p><p>　（3）存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。</p><h2 id="14-观察者模式"><a href="#14-观察者模式" class="headerlink" title="14 观察者模式"></a>14 观察者模式</h2><p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h3 id="14-1-模式结构图和代码示例"><a href="#14-1-模式结构图和代码示例" class="headerlink" title="14.1 模式结构图和代码示例"></a>14.1 模式结构图和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190611172644555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ul><li><p><strong>抽象被观察者角色</strong>：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</p></li><li><p><strong>抽象观察者角色</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p></li><li><p><strong>具体被观察者角色</strong>：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</p></li><li><p><strong>具体观察者角色</strong>：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</p></li></ul><p>举例（有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。）类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190611172644540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1、定义一个抽象被观察者接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">  public void registerObserver(Observer o);</span><br><span class="line">  public void removeObserver(Observer o);</span><br><span class="line">  public void notifyObserver();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义一个抽象观察者接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line"></span><br><span class="line">public void update(String message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class WechatServer implements Subject &#123;</span><br><span class="line"></span><br><span class="line">private List&lt;Observer&gt; list;</span><br><span class="line">private String message;</span><br><span class="line"></span><br><span class="line">public WechatServer() &#123;</span><br><span class="line">list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void registerObserver(Observer o) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void removeObserver(Observer o) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">if (!list.isEmpty()) &#123;</span><br><span class="line">list.remove(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void notifyObserver() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">for (Observer o : list) &#123;</span><br><span class="line">o.update(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setInfomation(String s) &#123;</span><br><span class="line">this.message = s;</span><br><span class="line">System.out.println(&quot;微信服务更新消息： &quot; + s);</span><br><span class="line">// 消息更新，通知所有观察者</span><br><span class="line">notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、定义具体观察者，微信公众号的具体观察者为用户User</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Observer &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private String message;</span><br><span class="line"></span><br><span class="line">public User(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void update(String message) &#123;</span><br><span class="line">this.message = message;</span><br><span class="line">read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">System.out.println(name + &quot; 收到推送消息： &quot; + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、编写一个测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        WechatServer server = new WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = new User(&quot;ZhangSan&quot;);</span><br><span class="line">        Observer userLi = new User(&quot;LiSi&quot;);</span><br><span class="line">        Observer userWang = new User(&quot;WangWu&quot;);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15 迭代器模式"></a>15 迭代器模式</h2><p><strong>定义：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>简单来说，不同种类的对象可能需要不同的遍历方式，我们对每一种类型的对象配一个迭代器，最后多个迭代器合成一个。</strong></p><p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p><p><strong>何时使用：</strong>遍历一个聚合对象。</p><p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p><strong>关键代码：</strong>定义接口：hasNext, next。</p><p><strong>应用实例：</strong>JAVA 中的 iterator。</p><p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><h3 id="15-1-模式结构和代码示例"><a href="#15-1-模式结构和代码示例" class="headerlink" title="15.1 模式结构和代码示例"></a>15.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190611195714196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>(1)迭代器角色（Iterator）:定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法next()，判断是否遍历结束的方法hasNext()），移出当前对象的方法remove(),</p><p>(2)具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。</p><p>(3)容器角色(Aggregate): 一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等</p><p>(4)具体容器角色（ConcreteAggregate）：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。</p><p>举例（咖啡厅和中餐厅合并，他们两个餐厅的菜单一个是数组保存的，一个是ArrayList保存的。遍历方式不一样，使用迭代器聚合访问，只需要一种方式）</p><p><img src="https://img-blog.csdnimg.cn/20190611195714224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1 迭代器接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line"></span><br><span class="line">public boolean hasNext();</span><br><span class="line">public Object next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 咖啡店菜单和咖啡店菜单遍历器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CakeHouseMenu &#123;</span><br><span class="line">private ArrayList&lt;MenuItem&gt; menuItems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CakeHouseMenu() &#123;</span><br><span class="line">menuItems = new ArrayList&lt;MenuItem&gt;();</span><br><span class="line"></span><br><span class="line">addItem(&quot;KFC Cake Breakfast&quot;,&quot;boiled eggs&amp;toast&amp;cabbage&quot;,true,3.99f);</span><br><span class="line">addItem(&quot;MDL Cake Breakfast&quot;,&quot;fried eggs&amp;toast&quot;,false,3.59f);</span><br><span class="line">addItem(&quot;Stawberry Cake&quot;,&quot;fresh stawberry&quot;,true,3.29f);</span><br><span class="line">addItem(&quot;Regular Cake Breakfast&quot;,&quot;toast&amp;sausage&quot;,true,2.59f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">float price) &#123;</span><br><span class="line">MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">menuItems.add(menuItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Iterator getIterator()</span><br><span class="line">&#123;</span><br><span class="line">return new CakeHouseIterator() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CakeHouseIterator implements  Iterator</span><br><span class="line"> &#123;</span><br><span class="line">private int position=0;</span><br><span class="line">public CakeHouseIterator()</span><br><span class="line">&#123;</span><br><span class="line">  position=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">if(position&lt;menuItems.size())</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object next() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MenuItem menuItem =menuItems.get(position);</span><br><span class="line">position++;</span><br><span class="line">return menuItem;</span><br><span class="line">&#125;&#125;;</span><br><span class="line">//鍏朵粬鍔熻兘浠ｇ爜</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 中餐厅菜单和中餐厅菜单遍历器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class DinerMenu &#123;</span><br><span class="line">private final static int Max_Items = 5;</span><br><span class="line">private int numberOfItems = 0;</span><br><span class="line">private MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line">public DinerMenu() &#123;</span><br><span class="line">menuItems = new MenuItem[Max_Items];</span><br><span class="line">addItem(&quot;vegetable Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&amp;cabbage&quot;, true, 3.58f);</span><br><span class="line">addItem(&quot;Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&quot;, false, 3.00f);</span><br><span class="line">addItem(&quot;bean soup&quot;, &quot;bean&amp;potato salad&quot;, true, 3.28f);</span><br><span class="line">addItem(&quot;hotdog&quot;, &quot;onions&amp;cheese&amp;bread&quot;, false, 3.05f);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">float price) &#123;</span><br><span class="line">MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">if (numberOfItems &gt;= Max_Items) &#123;</span><br><span class="line">System.err.println(&quot;sorry,menu is full!can not add another item&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">menuItems[numberOfItems] = menuItem;</span><br><span class="line">numberOfItems++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Iterator getIterator() &#123;</span><br><span class="line">return new DinerIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DinerIterator implements Iterator &#123;</span><br><span class="line">private int position;</span><br><span class="line"></span><br><span class="line">public DinerIterator() &#123;</span><br><span class="line">position = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">if (position &lt; numberOfItems) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object next() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MenuItem menuItem = menuItems[position];</span><br><span class="line">position++;</span><br><span class="line">return menuItem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 女服务员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Waitress &#123;</span><br><span class="line">private ArrayList&lt;Iterator&gt; iterators = new ArrayList&lt;Iterator&gt;();</span><br><span class="line"></span><br><span class="line">public Waitress() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addIterator(Iterator iterator) &#123;</span><br><span class="line">iterators.add(iterator);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printMenu() &#123;</span><br><span class="line">Iterator iterator;</span><br><span class="line">MenuItem menuItem;</span><br><span class="line">for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123;</span><br><span class="line">iterator = iterators.get(i);</span><br><span class="line"></span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">menuItem = (MenuItem) iterator.next();</span><br><span class="line">System.out</span><br><span class="line">.println(menuItem.getName() + &quot;***&quot; + menuItem.getPrice() + &quot;***&quot; + menuItem.getDescription());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printBreakfastMenu() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printLunchMenu() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printVegetableMenu() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-责任链模式"><a href="#16-责任链模式" class="headerlink" title="16 责任链模式"></a>16 责任链模式</h2><p><strong>定义：</strong>如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。</p><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p><p><strong>如何解决：</strong>拦截的类都实现统一接口。</p><p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><h3 id="16-1-模式的结构和代码示例"><a href="#16-1-模式的结构和代码示例" class="headerlink" title="16.1 模式的结构和代码示例"></a>16.1 模式的结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/2019061120335378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ol><li><p>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p></li><li><p>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p></li><li><p>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p></li></ol><p>举例（购买请求决策，价格不同要由不同的级别决定：组长、部长、副部、总裁）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190611203353118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1 决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Approver &#123;</span><br><span class="line"> Approver successor;</span><br><span class="line"> String Name;</span><br><span class="line">public Approver(String Name)</span><br><span class="line">&#123;</span><br><span class="line">this.Name=Name;</span><br><span class="line">&#125;</span><br><span class="line">public abstract void ProcessRequest( PurchaseRequest request);</span><br><span class="line">public void SetSuccessor(Approver successor) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">this.successor=successor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 客户端以及请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PurchaseRequest &#123;</span><br><span class="line">private int Type = 0;</span><br><span class="line">private int Number = 0;</span><br><span class="line">private float Price = 0;</span><br><span class="line">private int ID = 0;</span><br><span class="line"></span><br><span class="line">public PurchaseRequest(int Type, int Number, float Price) &#123;</span><br><span class="line">this.Type = Type;</span><br><span class="line">this.Number = Number;</span><br><span class="line">this.Price = Price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int GetType() &#123;</span><br><span class="line">return Type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public float GetSum() &#123;</span><br><span class="line">return Number * Price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int GetID() &#123;</span><br><span class="line">return (int) (Math.random() * 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public Client() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public PurchaseRequest sendRequst(int Type, int Number, float Price) &#123;</span><br><span class="line">return new PurchaseRequest(Type, Number, Price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 组长、部长。。。继承决策者抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class GroupApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">public GroupApprover(String Name) &#123;</span><br><span class="line">super(Name + &quot; GroupLeader&quot;);</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">if (request.GetSum() &lt; 5000) &#123;</span><br><span class="line">System.out.println(&quot;**This request &quot; + request.GetID() + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">successor.ProcessRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class DepartmentApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">public DepartmentApprover(String Name) &#123;</span><br><span class="line">super(Name + &quot; DepartmentLeader&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">if ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) &#123;</span><br><span class="line">System.out.println(&quot;**This request &quot; + request.GetID()</span><br><span class="line">+ &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">successor.ProcessRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Client mClient = new Client();</span><br><span class="line">Approver GroupLeader = new GroupApprover(&quot;Tom&quot;);</span><br><span class="line">Approver DepartmentLeader = new DepartmentApprover(&quot;Jerry&quot;);</span><br><span class="line">Approver VicePresident = new VicePresidentApprover(&quot;Kate&quot;);</span><br><span class="line">Approver President = new PresidentApprover(&quot;Bush&quot;);</span><br><span class="line"></span><br><span class="line">GroupLeader.SetSuccessor(VicePresident);</span><br><span class="line">DepartmentLeader.SetSuccessor(President);</span><br><span class="line">VicePresident.SetSuccessor(DepartmentLeader);</span><br><span class="line">President.SetSuccessor(GroupLeader);</span><br><span class="line"></span><br><span class="line">GroupLeader.ProcessRequest(mClient.sendRequst(1, 10000, 40));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-命令模式"><a href="#17-命令模式" class="headerlink" title="17 命令模式"></a>17 命令模式</h2><p><strong>定义：</strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销&#x2F;重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p><h3 id="17-1模式结构和代码示例"><a href="#17-1模式结构和代码示例" class="headerlink" title="17.1模式结构和代码示例"></a>17.1模式结构和代码示例</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20190612194014850.gif"></h2><ol><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者&#x2F;请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ol><p>代码举例（开灯和关灯），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190612194307560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1 命令抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line"></span><br><span class="line">public void excute();</span><br><span class="line">public void undo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体命令对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TurnOffLight implements Command &#123;</span><br><span class="line"></span><br><span class="line">private Light light;</span><br><span class="line"></span><br><span class="line">public TurnOffLight(Light light) &#123;</span><br><span class="line">this.light = light;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void excute() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">light.Off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void undo() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">light.On();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 实现者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Light &#123;</span><br><span class="line"></span><br><span class="line">String loc = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">public Light(String loc) &#123;</span><br><span class="line">this.loc = loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void On() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(loc + &quot; On&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Off() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(loc + &quot; Off&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 请求者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Contral&#123;</span><br><span class="line"></span><br><span class="line">public void CommandExcute(Command command) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">command.excute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void CommandUndo(Command command) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">command.undo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-状态模式"><a href="#18-状态模式" class="headerlink" title="18 状态模式"></a>18 状态模式</h2><p><strong>定义</strong>： 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p><p>简单理解，一个拥有状态的context对象，在不同的状态下，其行为会发生改变。</p><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p><p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p><p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p><p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><h3 id="18-1-模式结构和代码示例"><a href="#18-1-模式结构和代码示例" class="headerlink" title="18.1 模式结构和代码示例"></a>18.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612003537747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ul><li><p><strong>State抽象状态角色</strong></p><p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。</p></li><li><p><strong>ConcreteState具体状态角色</strong></p><p>具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。</p></li><li><p><strong>Context环境角色</strong></p><p>定义客户端需要的接口，并且负责具体状态的切换。</p></li></ul><p>举例（人物在地点A向地点B移动，在地点B向地点A移动）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190612003537942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1 state接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">public void stop();</span><br><span class="line">public void move();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 状态实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PlaceA implements State &#123;</span><br><span class="line"></span><br><span class="line">private Player context;</span><br><span class="line"></span><br><span class="line">public PlaceA(Player context) &#123;</span><br><span class="line">this.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;处于地点A,开始向B移动&quot;);</span><br><span class="line">System.out.println(&quot;--------&quot;);</span><br><span class="line">context.setDirection(&quot;AB&quot;);</span><br><span class="line">context.setState(context.onMove);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void stop() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;正处在地点A，不用停止移动&quot;);</span><br><span class="line">System.out.println(&quot;--------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 context(player)拥有状态的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line"></span><br><span class="line">State placeA;</span><br><span class="line">State placeB;</span><br><span class="line">State onMove;</span><br><span class="line">private State state;</span><br><span class="line">private String direction;</span><br><span class="line"></span><br><span class="line">public Player() &#123;</span><br><span class="line">direction = &quot;AB&quot;;</span><br><span class="line">placeA = new PlaceA(this);</span><br><span class="line">placeB = new PlaceB(this);</span><br><span class="line">onMove = new OnMove(this);</span><br><span class="line">this.state = placeA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;指令:开始移动&quot;);</span><br><span class="line">state.move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void stop() &#123;</span><br><span class="line">System.out.println(&quot;指令:停止移动&quot;);</span><br><span class="line">state.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public State getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setState(State state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDirection(String direction) &#123;</span><br><span class="line">this.direction = direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getDirection() &#123;</span><br><span class="line">return direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19 备忘录模式"></a>19 备忘录模式</h2><p>定义： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><p>备忘录模式是一种对象行为型模式，其主要优点如下。</p><ul><li><p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</p></li><li><p>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</p></li><li><p>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p></li></ul><p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p><h3 id="19-1-模式结构图和代码示例"><a href="#19-1-模式结构图和代码示例" class="headerlink" title="19.1 模式结构图和代码示例"></a>19.1 模式结构图和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612143829622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ol><li><p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p></li><li><p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p></li><li><p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p></li></ol><p>举例（发起者通过备忘录存储信息和获取信息），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190612143829817.png"></p><p>1 备忘录接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MementoIF &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 备忘录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Memento implements MementoIF&#123;</span><br><span class="line"></span><br><span class="line">private String state;</span><br><span class="line"></span><br><span class="line">public Memento(String state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getState()&#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 发起者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line"></span><br><span class="line">private String state;</span><br><span class="line"></span><br><span class="line">public String getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setState(String state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Memento saveToMemento() &#123;</span><br><span class="line">return new Memento(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getStateFromMemento(MementoIF memento) &#123;</span><br><span class="line">return ((Memento) memento).getState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 管理者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CareTaker &#123;</span><br><span class="line"></span><br><span class="line">private List&lt;MementoIF&gt; mementoList = new ArrayList&lt;MementoIF&gt;();</span><br><span class="line"></span><br><span class="line">public void add(MementoIF memento) &#123;</span><br><span class="line">mementoList.add(memento);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MementoIF get(int index) &#123;</span><br><span class="line">return mementoList.get(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-访问者模式"><a href="#20-访问者模式" class="headerlink" title="20 访问者模式"></a>20 访问者模式</h2><p><strong>定义：</strong>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。</p><p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p><ol><li><p>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</p></li><li><p>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</p></li><li><p>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</p></li></ol><p>访问者（Visitor）模式的主要缺点如下。</p><ol><li><p>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p></li><li><p>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</p></li><li><p>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p></li></ol><h3 id="20-1-模式结构和代码示例"><a href="#20-1-模式结构和代码示例" class="headerlink" title="20.1 模式结构和代码示例"></a>20.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612154308216.gif"></p><p>访问者模式包含以下主要角色。</p><ol><li><p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</p></li><li><p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p></li><li><p>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</p></li><li><p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p></li><li><p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p></li></ol><p>1 抽象访问者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Visitor &#123;</span><br><span class="line"></span><br><span class="line">abstract public void Visit(Element element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体访问者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void Visit(Element element) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">System.out.println(</span><br><span class="line">employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 抽象元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Element &#123;</span><br><span class="line">abstract public void Accept(Visitor visitor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 具体元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void Visit(Element element) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">System.out.println(</span><br><span class="line">employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 对象结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectStructure &#123;</span><br><span class="line">private HashMap&lt;String, Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">public ObjectStructure() &#123;</span><br><span class="line">employees = new HashMap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Attach(Employee employee) &#123;</span><br><span class="line">employees.put(employee.getName(), employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Detach(Employee employee) &#123;</span><br><span class="line">employees.remove(employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Employee getEmployee(String name) &#123;</span><br><span class="line">return employees.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Accept(Visitor visitor) &#123;</span><br><span class="line">for (Employee e : employees.values()) &#123;</span><br><span class="line">e.Accept(visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-中介者模式"><a href="#21-中介者模式" class="headerlink" title="21 中介者模式"></a>21 中介者模式</h2><p><strong>定义：</strong>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><p>中介者模式是一种对象行为型模式，其主要优点如下。</p><ol><li><p>降低了对象之间的耦合性，使得对象易于独立地被复用。</p></li><li><p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p></li></ol><p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h3 id="21-1-模式结构和代码示例"><a href="#21-1-模式结构和代码示例" class="headerlink" title="21.1 模式结构和代码示例"></a>21.1 模式结构和代码示例</h3><p><img src="https://img-blog.csdnimg.cn/20190612175348613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><ol><li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p></li></ol><p>举例（通过中介卖方），类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190612175348612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>1 抽象中介者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Mediator &#123;</span><br><span class="line"></span><br><span class="line">void register(Colleague colleague); // 客户注册</span><br><span class="line"></span><br><span class="line">void relay(String from, String to,String ad); // 转发</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 具体中介者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteMediator implements Mediator &#123;</span><br><span class="line"></span><br><span class="line">private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void register(Colleague colleague) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">if (!colleagues.contains(colleague)) &#123;</span><br><span class="line">colleagues.add(colleague);</span><br><span class="line">colleague.setMedium(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void relay(String from, String to, String ad) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">for (Colleague cl : colleagues) &#123;</span><br><span class="line"></span><br><span class="line">String name = cl.getName();</span><br><span class="line">if (name.equals(to)) &#123;</span><br><span class="line">cl.receive(from, ad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 抽象同事类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line"></span><br><span class="line">protected Mediator mediator;</span><br><span class="line">protected String name;</span><br><span class="line"></span><br><span class="line">public Colleague(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMedium(Mediator mediator) &#123;</span><br><span class="line"></span><br><span class="line">this.mediator = mediator;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void Send(String to, String ad);</span><br><span class="line"></span><br><span class="line">public abstract void receive(String from, String ad);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 具体同事类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Buyer extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">public Buyer(String name) &#123;</span><br><span class="line"></span><br><span class="line">super(name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void Send(String to, String ad) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">mediator.relay(name, to, ad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void receive(String from, String ad) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(name + &quot;接收到来自&quot; + from + &quot;的消息:&quot; + ad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端复习</title>
      <link href="/2022/10/07/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/10/07/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前端复习"><a href="#前端复习" class="headerlink" title="前端复习"></a>前端复习</h1><h1 id="概述与基础环境"><a href="#概述与基础环境" class="headerlink" title="概述与基础环境"></a>概述与基础环境</h1><p>将会涉及的内容<br><img src="https://img-blog.csdnimg.cn/49890d53e26d42769e185d8efba4f294.png" alt="在这里插入图片描述"></p><h2 id="安装Vscode"><a href="#安装Vscode" class="headerlink" title="安装Vscode"></a>安装Vscode</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>其他的安装问题不多赘述了，程序员不会装软件？我不信~</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>为方便后续开发，建议安装如下插件</p><p><img src="https://img-blog.csdnimg.cn/5d35aa15599d437d8fecde9216420c69.png" alt="在这里插入图片描述"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>vscode本身没有新建项目的选项，所以要先创建一个空的文件夹，如project_xxxx。</p><p>然后打开vscode，再在vscode里面选择 File -&gt; Open Folder 打开一个文件夹，这样才可以创建项目。</p><h3 id="保存工作区"><a href="#保存工作区" class="headerlink" title="保存工作区"></a>保存工作区</h3><p>打开文件夹后，选择“文件 -&gt; 将工作区另存为…”，为工作区文件起一个名字，存储在刚才的文件夹下即可<br><img src="https://img-blog.csdnimg.cn/a6b201bc6cc9405d97e2613399e5e971.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/452dcb41b3d342e38473f00c274ee874.png" alt="在这里插入图片描述"></p><h3 id="修改界面字体大小"><a href="#修改界面字体大小" class="headerlink" title="修改界面字体大小"></a>修改界面字体大小</h3><p>修改代码的大小可以在设置里进行<br>修改页面字体的大小可以通过Ctrl+加减号 来控制大小<br>修改出一个比较舒适的大小<br><img src="https://img-blog.csdnimg.cn/1a28eaee071b420dbe7996e389b9053e.png" alt="在这里插入图片描述"><br>启动运行<br><img src="https://img-blog.csdnimg.cn/55e395a54d5641d2a23a5416e07ce8b6.png" alt="在这里插入图片描述"></p><h1 id="ES6学习"><a href="#ES6学习" class="headerlink" title="ES6学习"></a>ES6学习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>认识认识ES6的历史<br>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p><strong>与JavaScript 的关系</strong></p><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）</p><p>与 ECMAScript 2015 的关系</p><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p><p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p><p>ES6 的第一个版本，在 2015 年 6 月发布，正式名称是《ECMAScript 2015 标准》（简称 ES2015）。</p><p>2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小，基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p><p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><p>历史介绍完毕，直接学语法</p><h2 id="ES6基础语法"><a href="#ES6基础语法" class="headerlink" title="ES6基础语法"></a>ES6基础语法</h2><p>ES标准中不包含 DOM 和 BOM的定义，只涵盖基本数据类型、关键字、语句、运算符、内建对象、内建函数等通用语法。</p><p>本部分只学习前端开发中ES6的最少必要知识，方便后面项目开发中对代码的理解。</p><h3 id="let声明变量"><a href="#let声明变量" class="headerlink" title="let声明变量"></a>let声明变量</h3><p>创建 let.html<br>在ES6中，定义变量不光用var，还要用let<br>但是let出了大括号就不认识了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// var 可以声明多次 可以有两个一样的</span></span><br><span class="line">    <span class="comment">// let 只能声明一次 不可以有两个一样的</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//控制台打印</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8ba25118afc84984bfedd7481ec904e7.png" alt="在这里插入图片描述"></p><h3 id="const声明常量（只读）"><a href="#const声明常量（只读）" class="headerlink" title="const声明常量（只读）"></a>const声明常量（只读）</h3><p>常量生成完，是不许改变的<br>同时，初始值是必须赋值的，不赋值会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//const声明的变量是只读变量，不允许再更改，且需要赋值</span></span><br><span class="line">           <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="string">&quot;3.1415926&quot;</span></span><br><span class="line">           <span class="variable constant_">PI</span> = <span class="number">3</span> <span class="comment">//TypeError: Assignment to constant variable.</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//控制台打印会报错</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>) </span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b5cda3dbb51e4f1f9fe2afdd005f3f9f.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/80a09c2f78a746af88c5a25d5e13f046.png" alt="在这里插入图片描述"></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是对赋值运算符的扩展。</p><p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p><p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p>获取的时候注意key要和对象创建时的key要对应上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//对象解构</span></span><br><span class="line">    <span class="keyword">let</span> user = &#123;<span class="attr">name</span>: <span class="string">&#x27;Helen&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">    <span class="comment">// 传统写法</span></span><br><span class="line">    <span class="keyword">let</span> name1 = user.<span class="property">name</span></span><br><span class="line">    <span class="keyword">let</span> age1 = user.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name1, age1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ES6中的简写,直接可以获取到</span></span><br><span class="line">    <span class="keyword">let</span> &#123;name,age&#125;=user</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name) </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/65a2a071743740ee9072107ac3e5a7fa.png" alt="在这里插入图片描述"></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串相当于加强版的字符串，<strong>用反引号 `</strong> ,除了作为普通字符串，还可以在字符串中加入变量和表达式。<br>注意，用的时候一定一定要引入反引号，其他的引号不生效！<br><img src="https://img-blog.csdnimg.cn/e41001804ea94f20a3d94c2b05c5d627.png" alt="在这里插入图片描述"></p><h3 id="定义方法简写"><a href="#定义方法简写" class="headerlink" title="定义方法简写"></a>定义方法简写</h3><p>ES6中也可以做出类似Java的方法编写，和类差不多，里面有属性，有方法<br>说白了就是少写了个function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 传统</span></span><br><span class="line">    <span class="keyword">const</span> person1 = &#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;cc&quot;</span>,</span><br><span class="line">        <span class="attr">info</span>:&#123;<span class="string">&quot;aa&quot;</span>:<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>:<span class="string">&quot;bb&quot;</span>&#125;,</span><br><span class="line">        <span class="attr">sayHi</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;传统Hi&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;<span class="comment">//调用</span></span><br><span class="line">    person1.<span class="title function_">sayHi</span>();<span class="comment">//&quot;Hi&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES6</span></span><br><span class="line">    <span class="keyword">const</span> person2 = &#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;cc&quot;</span>,</span><br><span class="line">        <span class="attr">info</span>:&#123;<span class="string">&quot;aa&quot;</span>:<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>:<span class="string">&quot;bb&quot;</span>&#125;,</span><br><span class="line">        <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;简写Hi&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//调用</span></span><br><span class="line">    person2.<span class="title function_">sayHi</span>()  <span class="comment">//&quot;Hi&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><p>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 1、拷贝对象</span></span><br><span class="line">    <span class="keyword">let</span> person1 = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> someone = &#123; ...person1 &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(someone)  <span class="comment">//&#123;name: &quot;Amy&quot;, age: 15&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>类似lamdba的箭头函数简化方法体的定义<br>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：<code>参数 =&gt; 函数体</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 传统</span></span><br><span class="line">    <span class="keyword">var</span> f1=<span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f1</span>(<span class="number">111</span>))<span class="comment">//111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES6</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f2</span> = a =&gt; a</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f2</span>(<span class="number">1</span>))<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f3</span> = (<span class="params">a,b</span>) =&gt; a+b</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f3</span>(<span class="number">3</span>,<span class="number">4</span>))<span class="comment">//7</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/f17d8c08d3f3492d9a7c2285bfda1d0e.png" alt="在这里插入图片描述"></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h3><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。</p><p>Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>官方网站：<a href="https://cn.vuejs.org/">https://cn.vuejs.org</a></p><h3 id="环境搭建与内容抽取"><a href="#环境搭建与内容抽取" class="headerlink" title="环境搭建与内容抽取"></a>环境搭建与内容抽取</h3><p>提前把Vue的包引入进来 ，复制粘贴js文件到包下<br><img src="https://img-blog.csdnimg.cn/2d83e5031502467c86a2ef258f839ba0.png" alt="在这里插入图片描述"><br>快速开始，引入这些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- id标识vue作用的范围 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 插值表达式，绑定vue中的data数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 创建一个vue对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,<span class="comment">//绑定vue作用的范围</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>: &#123;<span class="comment">//定义页面中显示的模型数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>但是这些都是标准的模板，写来写去就那些东西，不想重复写了怎么办<br>把这些内容抽取出来</p><p><strong>在vs code中创建代码片段：</strong></p><p>文件 &#x3D;&gt; 首选项 &#x3D;&gt; 用户代码片段 &#x3D;&gt; 新建全局代码片段&#x2F;或文件夹代码片段：vue-html.code-snippets</p><p><strong>注意：制作代码片段的时候，字符串中如果包含文件中复制过来的“Tab”键的空格，要换成“空格键”的空格</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;vue htm&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;vuehtml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;&lt;!DOCTYPE html&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;html lang=\&quot;en\&quot;&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;head&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;meta charset=\&quot;UTF-8\&quot;&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;ie=edge\&quot;&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;title&gt;Document&lt;/title&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/head&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;body&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;div id=\&quot;app\&quot;&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;/div&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;script src=\&quot;vue.min.js\&quot;&gt;&lt;/script&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;script&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;        new Vue(&#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;            el: &#x27;#app&#x27;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;            data: &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;                $1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;            &#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;        &#125;)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;    &lt;/script&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/body&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/html&gt;&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;my vue template in html&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在创建新html的时候，输入vuehtml自动生成<br><img src="https://img-blog.csdnimg.cn/157da8576adf46868ef53b25c6fef678.png" alt="在这里插入图片描述"></p><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><p>抄以前的笔记，这里不想再写一遍了，节约时间<br>有相关的笔记<br><a href="https://blog.csdn.net/weixin_46906696/article/details/124447819">Vue快速入门及案例</a></p><h3 id="v-text赋值文本内容"><a href="#v-text赋值文本内容" class="headerlink" title="v-text赋值文本内容"></a>v-text赋值文本内容</h3><blockquote><p>作用：将数据设置给标签的文本内容，设置标签的文本值（textContent）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-text=<span class="string">&quot;绑定对象data的key+&#x27;拼接的内容&#x27;&quot;</span>&gt;内部内容测试&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;对象.属性值&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7059c98ea2514f3bb6b7c69f56e1ac9a.png" alt="在这里插入图片描述"><br>表达式也可以进行拼接<br><img src="https://img-blog.csdnimg.cn/4757402617e14b7c9682aaf6b9b3b60e.png" alt="在这里插入图片描述"><br>总结：<br><img src="https://img-blog.csdnimg.cn/6155e3bda3134ae2856e2b38ae512905.png" alt="在这里插入图片描述"></p><h3 id="v-html解析html代码"><a href="#v-html解析html代码" class="headerlink" title="v-html解析html代码"></a>v-html解析html代码</h3><blockquote><p>作用：设置标签的innerHtml，能够识别并且解析html代码，而不是html代码变成文字</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-html=<span class="string">&quot;绑定对象&quot;</span>&gt;这里的内容会被覆盖！&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;绑定对象&quot;</span>&gt;</span>这里的内容会被覆盖！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">...诸如此类的用法</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cbf95da3e09a46009dcd117d05c25cd3.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a30b42d5ecb84b63b510188420481a83.png" alt="在这里插入图片描述"><br>总结：<br><img src="https://img-blog.csdnimg.cn/bcdb5417f09d48a490c5e3ac090dca7a.png" alt="在这里插入图片描述"></p><h3 id="v-on为元素绑定事件"><a href="#v-on为元素绑定事件" class="headerlink" title="v-on为元素绑定事件"></a>v-on为元素绑定事件</h3><blockquote><p>作用：为元素绑定事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      &lt;input type=<span class="string">&quot;button&quot;</span> v-<span class="attr">on</span>:触发方式=<span class="string">&quot;函数名&quot;</span> value=<span class="string">&quot;按钮内的内容&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">触发方式</span>=<span class="string">&quot;函数名&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮内的内容&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/330a3173137f423da6670a7952f0ed67.png" alt="在这里插入图片描述"><br>效果<br><img src="https://img-blog.csdnimg.cn/8539f4799af3481e805eeb7b07abe7d4.png" alt="在这里插入图片描述"><br>如何获取同一个app对象下（挂载数据）的内容呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">data</span>数据中的key就可以获取</span><br></pre></td></tr></table></figure><p>案例：<br><img src="https://img-blog.csdnimg.cn/357357f6b6ce40589adb45fc24234311.png" alt="在这里插入图片描述"><br>总结：<br><img src="https://img-blog.csdnimg.cn/c7f20c3698384b20b33ae5359cc307d1.png" alt="在这里插入图片描述"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><img src="https://img-blog.csdnimg.cn/1da458d2b358445b931559814392e0f4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/76ac7d6debe94332a1154976241f1526.png" alt="在这里插入图片描述"></p><h3 id="实现一个计数器"><a href="#实现一个计数器" class="headerlink" title="实现一个计数器"></a>实现一个计数器</h3><p>计数器长这个样子<br><img src="https://img-blog.csdnimg.cn/a2fed6d5b26748b983106aeed5b94c45.png" alt="在这里插入图片描述"><br>body体里面的代码，其他头部的代码没啥用，这里不赘述了<br>这里改了一点点需求，加随便加，减不能减过0<br><img src="https://img-blog.csdnimg.cn/fe8086059a574f3382992e5010d90a77.png" alt="在这里插入图片描述"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;result&quot;</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sub()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">result</span>: <span class="number">10</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">add</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">result</span>++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">sub</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">result</span>==<span class="number">0</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">alert</span>(<span class="string">&quot;已经为0了，不能再减!&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">result</span>--;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>还就那个效果拔群<br><img src="https://img-blog.csdnimg.cn/11406e25302d4b37a76d577ba4e4170e.png" alt="在这里插入图片描述"><br>总结<br><img src="https://img-blog.csdnimg.cn/d055a5a4847e4283990ea95724e50927.png" alt="在这里插入图片描述"></p><h3 id="v-show元素显示和隐藏"><a href="#v-show元素显示和隐藏" class="headerlink" title="v-show元素显示和隐藏"></a>v-show元素显示和隐藏</h3><blockquote><p>表达式的真假来切换元素的显示状态标签内部的一个元素，true和false来标示元素是否能够显示<br>注意：频繁切换的话用v-show更好</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-show=<span class="string">&quot;true（显示）/false（不显示）&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f4cc4f03b5b1444485b170f77e97d6b8.png" alt="在这里插入图片描述"><br>定义在data中<br><img src="https://img-blog.csdnimg.cn/c282dd8652104236ad3c0fad40c0a1ad.png" alt="在这里插入图片描述"><br>同时也支持表达式的运算<br><img src="https://img-blog.csdnimg.cn/df4de90ec3aa468cb941a0d31e5af29f.png" alt="在这里插入图片描述"><br>实例：<br><img src="https://img-blog.csdnimg.cn/6fdc2fa4f1124570bfa38039504db0c3.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b5be68fedbf84e6ca40dc99dc7de163e.png" alt="在这里插入图片描述"><br>切换显示效果的小demo<br>需求是按键来切换元素的显示<br>这里只写body体内部的代码，其他的部分写出来意义不大<br>单击按钮实现图片的显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShowEl()&quot;</span>&gt;</span>&quot;是否显示元素？&quot;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片路径&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">isShow</span>:<span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">isShowEl</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">isShow</span>=!<span class="variable language_">this</span>.<span class="property">isShow</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>总结：<br><img src="https://img-blog.csdnimg.cn/b856eeba24f145cebca404054a0fc462.png" alt="在这里插入图片描述"></p><h3 id="v-if元素显示和隐藏"><a href="#v-if元素显示和隐藏" class="headerlink" title="v-if元素显示和隐藏"></a>v-if元素显示和隐藏</h3><p>根据表达式的真假，切换元素的显示和隐藏</p><blockquote><p>v-if是来操作不频繁切换的元素更好<br>注意：频繁切换的话用v-show更好<br>原理就是操纵dom树，加入display：none属性，不显示的时候就改为true</p></blockquote><p>v-show与v-if的区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</span><br><span class="line">2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</span><br><span class="line">3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</span><br><span class="line">4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</span><br></pre></td></tr></table></figure><p>语法和上面的v-show差不多<br><img src="https://img-blog.csdnimg.cn/22cb5afd4c444987ad0326f125aa501c.png" alt="在这里插入图片描述"><br>总结<br><img src="https://img-blog.csdnimg.cn/06c943de9e924dc2b3756799232432f9.png" alt="在这里插入图片描述"></p><h3 id="v-bind操纵属性"><a href="#v-bind操纵属性" class="headerlink" title="v-bind操纵属性"></a>v-bind操纵属性</h3><p>设置元素的属性<br>语法：<br><img src="https://img-blog.csdnimg.cn/8f907e0f343c46b5b19337a5971cd6d8.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/dd043b30905f4844b0268b4c87d7a54f.png" alt="在这里插入图片描述"><br>简略写法<br><img src="https://img-blog.csdnimg.cn/dca9fb9a1877466d95a16d995e4b9be8.png" alt="在这里插入图片描述"><br>成功操纵样式的显示<br><img src="https://img-blog.csdnimg.cn/9796989770b842dca48d5233517f51ea.png" alt="在这里插入图片描述"><br>总结<br><img src="https://img-blog.csdnimg.cn/70e51c722155452e87beb0038b352b0e.png" alt="在这里插入图片描述"></p><h3 id="实现一个图片切换案例"><a href="#实现一个图片切换案例" class="headerlink" title="实现一个图片切换案例"></a>实现一个图片切换案例</h3><p>长这个样子<br><img src="https://img-blog.csdnimg.cn/a050ea00ca254e02b402fbe58c4214d9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/9026c018531e4049b6e6505aa462e745.png" alt="在这里插入图片描述"><br>具体思路：<br><img src="https://img-blog.csdnimg.cn/a23ac23531aa4670939c828d54385157.png" alt="在这里插入图片描述"><br>老规矩，只写body里的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;preImg()&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;index!=0&quot;</span>&gt;</span>切换上一张<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">imgArray[index]</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;nextImg()&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;index!=imgArray.length-1&quot;</span>&gt;</span>切换下一张<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">imgArray</span>:[</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;./img/01.png&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;./img/02.png&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;./img/03.png&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;./img/04.png&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;./img/05.png&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">index</span>:<span class="number">0</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">preImg</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">index</span>--;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">nextImg</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">this</span>.<span class="property">index</span>++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>单机按钮来切换上下张<br><img src="https://img-blog.csdnimg.cn/971ba06b6f834fffb4faecf18cc6f4c7.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/df336936f0c745669d1e95138a881e45.png" alt="在这里插入图片描述"><br><strong>亮点：用v-bind来动态的操作img标签内的src元素的属性是最重要的</strong><br>总结：<br><img src="https://img-blog.csdnimg.cn/cddd07e392f44c5ea4f10d35a808bc24.png" alt="在这里插入图片描述"></p><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><blockquote><p>响应式的根据数据生成列表结构</p></blockquote><p>因为是要显示列表，这里回顾一下无序列表的语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>需要显示的条目内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">li：list litm的缩写：条目列表。list：列表；item:条目</span><br></pre></td></tr></table></figure><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(对象名称随便起,下标名称随便起) in 数组名&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">测试v-for:&#123;&#123; 上面起的对象名 &#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/220e4bf38af144b490f9807b9b67fe39.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b5bed14d8a3b4994a0668d53880f91d4.png" alt="在这里插入图片描述"><br>总结：<br><img src="https://img-blog.csdnimg.cn/bc9075500a5249fd88efa598e1469f46.png" alt="在这里插入图片描述"></p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><blockquote><p>作用：把表单中的值和实例中的数据关联起来（双向数据绑定）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f72e0ed522fc44bdb9e19aaaf065b649.png" alt="在这里插入图片描述"><br>案例<br><img src="https://img-blog.csdnimg.cn/f8a8611a2baf40a0859b2ec079355d81.png" alt="在这里插入图片描述"><br>总结：<br><img src="https://img-blog.csdnimg.cn/573d9461def44b39b290e338b157c7ce.png" alt="在这里插入图片描述"></p><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>抄个作业<br><img src="https://img-blog.csdnimg.cn/38a0e747b91d4bf0974d75198cc6cb1b.png" alt="在这里插入图片描述"></p><p>主要的生命周期方法就这两个<br><img src="https://img-blog.csdnimg.cn/1c68d3b70e5a428382f561271d945335.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8f04b1f005384d668db514d1b91f03c0.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/4ad5fed2dbd04365b0f7e68fb8d18992.png" alt="在这里插入图片描述"><br>放行之后，渲染完成<br><img src="https://img-blog.csdnimg.cn/2a6991363b04496699b8c4ebc9202fc3.png" alt="在这里插入图片描述"><br>控制台也可以正常输出了<br><img src="https://img-blog.csdnimg.cn/097b6908575546019b0c04e0f9d6036d.png" alt="在这里插入图片描述"></p><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树</p><p>说白了就是自定义一个HTML标签<br><img src="https://img-blog.csdnimg.cn/1fe814a41717477ea71ce585a30d8b28.png" alt="在这里插入图片描述"></p><p>定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="comment">// 定义局部组件，这里可以定义多个局部组件</span></span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="comment">//组件的名字</span></span><br><span class="line">        <span class="string">&#x27;自定义名字&#x27;</span>: &#123;</span><br><span class="line">            <span class="comment">//组件的内容</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;&lt;ul&gt;&lt;li&gt;首页&lt;/li&gt;&lt;li&gt;学员管理&lt;/li&gt;&lt;/ul&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;自定义组件名称&gt;&lt;/自定义组件名称&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e23a7efb8fd44ad58ea15e450efe21c6.png" alt="在这里插入图片描述"></p><h2 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h2><p>Vue.js 路由允许我们通过不同的 URL 访问不同的内容。</p><p>通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。</p><p>Vue.js 路由需要载入 vue-router 库</p><p>创建 路由.html</p><p><img src="https://img-blog.csdnimg.cn/7a12ff4fb73a492ba365ab3687450e99.png" alt="在这里插入图片描述"><br>使用步骤<br><strong>引入js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>编写HTML</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/student&quot;</span>&gt;</span>会员管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/teacher&quot;</span>&gt;</span>讲师管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 路由出口 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>编写JS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 1. 定义（路由）组件。</span></span><br><span class="line">    <span class="comment">// 可以从其他文件 import 进来</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Welcome</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;欢迎&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Student</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;student list&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Teacher</span> = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;teacher list&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line">    <span class="comment">// 2. 定义路由</span></span><br><span class="line">    <span class="comment">// 每个路由应该映射一个组件。</span></span><br><span class="line">    <span class="keyword">const</span> routes = [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/welcome&#x27;</span> &#125;, <span class="comment">//设置默认指向的路径</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/welcome&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Welcome</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/student&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Student</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/teacher&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Teacher</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">        routes <span class="comment">// （缩写）相当于 routes: routes</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 4. 创建和挂载根实例。</span></span><br><span class="line">    <span class="comment">// 从而让整个应用都有路由功能</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        router</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 现在，应用已经启动了！</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>这里只介绍快速使用，这个案例里有具体的用法<br><a href="https://blog.csdn.net/weixin_46906696/article/details/124447819">Vue快速入门及案例</a></p><p>axios是独立于vue的一个项目，基于promise用于浏览器和node.js的http客户端</p><ul><li>在浏览器中可以帮助我们完成 ajax请求的发送</li><li>在node.js中可以向远程接口发送请求</li></ul><p>导入依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>写个json，给请求做数据响应<br><img src="https://img-blog.csdnimg.cn/f50ddec3e270442c8eca2cbe3d5e84dc.png" alt="在这里插入图片描述"><br>JS部分代码（Get请求版本）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">var</span> app=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">memberList</span>: []<span class="comment">//数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="title function_">created</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="variable language_">this</span>.<span class="title function_">getList</span>()<span class="comment">//页面渲染前就调用当前Vue中的getList方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="title function_">getList</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   <span class="comment">//vm = this</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   <span class="comment">//axios.get(&#x27;请求路径&#x27;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   axios.<span class="title function_">get</span>(<span class="string">&#x27;test.json&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="comment">//请求成功</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="comment">//此时去前端控制台，已经可以打印数据了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="variable language_">this</span>.<span class="property">memberList</span> = response.<span class="property">data</span>.<span class="property">data</span>.<span class="property">name</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="comment">//请求失败</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                   &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>获取数据显示一下<br><img src="https://img-blog.csdnimg.cn/e6766ffb8d4e4aac8c712a5479b71995.png" alt="在这里插入图片描述"></p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>什么是Node.js</p><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p><p>Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p><p>浏览器的内核包括两部分核心：</p><ul><li>DOM渲染引擎；</li><li>js解析器（js引擎）</li><li>js运行在浏览器中的内核中的js引擎内部</li></ul><p><strong>Node.js有什么用</strong></p><p>如果你是一个前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那么Node.js是一个非常好的选择。</p><p>Node.js 是运行在服务端的 JavaScript，如果你熟悉Javascript，那么你将会很容易的学会Node.js。</p><p>当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。</p><p>Node.js类似于JRE，专门给JS做运行环境的，也可以作为后端开发使用</p><h2 id="下载安装Node-js"><a href="#下载安装Node-js" class="headerlink" title="下载安装Node.js"></a>下载安装Node.js</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>中文网：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p><p>LTS：长期支持版本</p><p>Current：最新版</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>安装和查看版本<br><img src="https://img-blog.csdnimg.cn/ed4e397ee6c840c99c6efe26ad020e71.png" alt="在这里插入图片描述"></p><h3 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h3><p>新建一个js文件</p><p><img src="https://img-blog.csdnimg.cn/089ac72b6350401481b7a1ea22dc67f7.png" alt="在这里插入图片描述"><br>进入到程序所在的目录，输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node <span class="number">01</span>.js</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/56ee7d7c9e0a46468f2fb4e7629a189d.png" alt="在这里插入图片描述"><br>可以发现，无需网页，就可以很好的运行js文件</p><h3 id="Vscode使用Nodejs"><a href="#Vscode使用Nodejs" class="headerlink" title="Vscode使用Nodejs"></a>Vscode使用Nodejs</h3><p>在Vscode里也可以完成相关操作<br><img src="https://img-blog.csdnimg.cn/575bbf8b24fd45b2ba80b744d9a3b991.png" alt="在这里插入图片描述"></p><h3 id="Vscode使用Nodejs的相关问题"><a href="#Vscode使用Nodejs的相关问题" class="headerlink" title="Vscode使用Nodejs的相关问题"></a>Vscode使用Nodejs的相关问题</h3><p><img src="https://img-blog.csdnimg.cn/fd8b2ed6a108443d915fe6f2544e05ee.png" alt="在这里插入图片描述"></p><h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h3><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 来管理各种src引入的依赖。</p><h2 id="安装NPM"><a href="#安装NPM" class="headerlink" title="安装NPM"></a>安装NPM</h2><p>我们通过npm 可以很方便地下载js库，管理前端工程。</p><p>Node.js默认安装的npm包和工具的位置：Node.js目录\node_modules</p><ul><li>在这个目录下你可以看见 npm目录，npm本身就是被NPM包管理器管理的一个工具，说明 Node.js已经集成了npm工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在命令提示符输入 npm -v 可查看当前npm版本</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>Vscode中的继承命令窗口<br><img src="https://img-blog.csdnimg.cn/b7989c27ea77461bb618f9e7c58cf31a.png" alt="在这里插入图片描述"></p><h2 id="NPM管理项目"><a href="#NPM管理项目" class="headerlink" title="NPM管理项目"></a>NPM管理项目</h2><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>创建文件夹npm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立一个空文件夹，在命令提示符进入该文件夹  执行命令初始化</span></span><br><span class="line">npm init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照提示输入相关信息，如果是用默认值则直接回车即可。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">name: 项目名称</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">version: 项目版本号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">description: 项目描述</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">keywords: &#123;Array&#125;关键词，便于用户搜索到我们的项目</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们之后也可以根据需要进行修改。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果想直接按默认的生成 package.json 文件，那么可以使用命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样就不需要后续的确认了</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="修改npm镜像"><a href="#修改npm镜像" class="headerlink" title="修改npm镜像"></a>修改npm镜像</h3><p>NPM官方的管理的包都是从 <a href="http://npmjs.com下载的,但是这个网站在国内速度很慢./">http://npmjs.com下载的，但是这个网站在国内速度很慢。</a></p><p>这里推荐使用淘宝 NPM 镜像 <a href="http://npm.taobao.org/">http://npm.taobao.org/</a> ，淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。</p><p><strong>设置镜像地址：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看npm配置信息</span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure><h3 id="npm-install命令的使用"><a href="#npm-install命令的使用" class="headerlink" title="npm install命令的使用"></a>npm install命令的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 npm install 安装依赖包的最新版，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">模块安装的位置：项目目录\node_modules</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 &lt;dependencies&gt;</span></span><br><span class="line">npm install jquery</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">npm管理的项目在备份和传输的时候一般不携带node_modules文件夹</span></span><br><span class="line">npm install #根据package.json中的配置下载依赖，初始化项目</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果安装时想指定特定的版本</span></span><br><span class="line">npm install jquery@2.1.x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">局部安装</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 -D参数将依赖添加到devDependencies节点</span></span><br><span class="line">npm install --save-dev eslint</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">npm install -D eslint</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局安装</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Node.js全局安装的npm包和工具的位置：用户目录\AppData\Roaming\npm\node_modules</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一些命令行工具常使用全局安装的方式</span></span><br><span class="line">npm install -g webpack</span><br><span class="line">            --global</span><br></pre></td></tr></table></figure><p>下载一个JQuery依赖<code>npm install jquery</code><br>这个时候，package-lock.json（前端版Pom）新的依赖信息就进来了<br><img src="https://img-blog.csdnimg.cn/af10e0ba157844c0adb4162d3435e787.png" alt="在这里插入图片描述"></p><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新包（更新到最新版本）</span></span><br><span class="line">npm update 包名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局更新</span></span><br><span class="line">npm update -g 包名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载包</span></span><br><span class="line">npm uninstall 包名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局卸载</span></span><br><span class="line">npm uninstall -g 包名</span><br></pre></td></tr></table></figure><h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。<br>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。<br>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），包（package）等概念，更遑论”模块”（module）了。</p><p>传统非模块化开发有如下的缺点：</p><ul><li>命名冲突</li><li>文件依赖</li></ul><p>模块化规范：</p><ul><li>CommonJS模块化规范</li><li>ES6模块化规范</li></ul><h2 id="ES5模块化写法"><a href="#ES5模块化写法" class="headerlink" title="ES5模块化写法"></a>ES5模块化写法</h2><p>先初始化一下工程 ES6也是如此<br><img src="https://img-blog.csdnimg.cn/1ebbc0bd7ff34adaaf43543cfee86c59.png" alt="在这里插入图片描述"></p><p>每个文件就是一个模块，有自己作用域。在一个文件里定义的变量、函数、类，都是私有的，对其他文件不可见。如果不设置的话，其他js文件是调用不了的。<br>在ES5模块化中，创建两个js文件<br>一个01.js，另一个02.js，01中的方法可以被02调用<br>01.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个成员函数：</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(a) + <span class="built_in">parseInt</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> subtract = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(a) - <span class="built_in">parseInt</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义可以被外界JS访问的函数</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    sum,</span><br><span class="line">    subtract</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>02.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把01的函数引进来，类似于import的操作</span></span><br><span class="line"><span class="comment">//同时用对象进行接收，方便后续调用。./ 代表当前路径</span></span><br><span class="line"><span class="keyword">const</span> m=<span class="built_in">require</span>(<span class="string">&quot;./01.js&quot;</span>)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> sumResult=m.<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> subtractResult=m.<span class="title function_">subtractResult</span>(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumResult)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(subtractResult)</span><br></pre></td></tr></table></figure><p>node 02.js运行一下<br><img src="https://img-blog.csdnimg.cn/4ae2fa0c0a704b4b9e1091eb61d9c35f.png" alt="在这里插入图片描述"></p><h2 id="ES6模块化写法"><a href="#ES6模块化写法" class="headerlink" title="ES6模块化写法"></a>ES6模块化写法</h2><p>还是一样需要初始化工程<br>创建es6-01.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入export就可以被其他js文件读取，类似访问权限控制</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params">b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建es6-02.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import &#123;函数1，函数2&#125; from &quot;文件路径&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;test1,test2&#125; <span class="keyword">from</span> <span class="string">&quot;./es6-01.js&quot;</span></span><br><span class="line"><span class="comment">//直接可以调用</span></span><br><span class="line"><span class="title function_">test1</span>(<span class="number">123</span>)</span><br><span class="line"><span class="title function_">test2</span>(<span class="number">456</span>)</span><br></pre></td></tr></table></figure><p>node运行一下<br><img src="https://img-blog.csdnimg.cn/a7e56ed1d5754b58a221c3cb98bdc883.png" alt="在这里插入图片描述"></p><h3 id="安装Babel"><a href="#安装Babel" class="headerlink" title="安装Babel"></a>安装Babel</h3><p>Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行执行</p><p>Babel提供babel-cli工具，用于命令行转码。它的安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global babel-cli</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">babel --version</span><br></pre></td></tr></table></figure><h4 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置.babelrc</h4><p>Babel的配置文件是.babelrc，存放在项目的根目录下，该文件用来设置转码规则和插件，presets字段设定转码规则，将es2015规则加入 .babelrc：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="安装转码器"><a href="#安装转码器" class="headerlink" title="安装转码器"></a>安装转码器</h4><p>在项目中安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br></pre></td></tr></table></figure><h4 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">整个目录转码</span></span><br><span class="line">mkdir dist1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">babel src -d dist1</span><br></pre></td></tr></table></figure><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node dist1/userComponent.js</span><br></pre></td></tr></table></figure><h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>01.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入export就可以被其他js文件的对象调用了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun1&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>02.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import 对象 from &quot;文件路径&quot;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&quot;./es6-01.js&quot;</span></span><br><span class="line"><span class="comment">//通过对象来调用</span></span><br><span class="line">user.<span class="title function_">fun1</span>()</span><br><span class="line">user.<span class="title function_">fun2</span>()</span><br></pre></td></tr></table></figure><p>同样，想使用也需要转码成ES5</p><h1 id="前端基础搭建（后台）"><a href="#前端基础搭建（后台）" class="headerlink" title="前端基础搭建（后台）"></a>前端基础搭建（后台）</h1><h2 id="vue-admin-template模板"><a href="#vue-admin-template模板" class="headerlink" title="vue-admin-template模板"></a>vue-admin-template模板</h2><p>vue-admin-template是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为模板进行二次开发。</p><p><img src="https://img-blog.csdnimg.cn/88aba2d12a444b328bd41637927e49fe.png" alt="在这里插入图片描述"></p><p>GitHub地址：<a href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a></p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>把文件复制到Vscode下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压压缩包</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd vue-admin-template-master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动。执行后，浏览器自动弹出并访问http://localhost:9528/</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/02c6d2e8de7b4572b2ccafb7edfcf8e4.png" alt="在这里插入图片描述"><br>引入成功之后，运行起来<br><img src="https://img-blog.csdnimg.cn/1fae7e48f33346cf8ee33ff56cd6fb84.png" alt="在这里插入图片描述"></p><h2 id="登陆改造"><a href="#登陆改造" class="headerlink" title="登陆改造"></a>登陆改造</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>原先的登陆数据是用mook.json也就是模拟文件<br>现在自己写两个后端接口专门去返回这种成功登陆的模拟Json<br>具体位置在：<img src="https://img-blog.csdnimg.cn/e9983db8c7ea4988aa93a34c5cb250a5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/536aa840461d4b5980028c794df6e4f0.png" alt="在这里插入图片描述"></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端主要是修改请求路径<br><img src="https://img-blog.csdnimg.cn/1425dbace1d24003969b401c45236d54.png" alt="在这里插入图片描述"><br>除此之外还要修改js文件中的请求路径<br><img src="https://img-blog.csdnimg.cn/2c5a080cdaf6437ea3e70fca70affaeb.png" alt="在这里插入图片描述"><br>总结一下<br><img src="https://img-blog.csdnimg.cn/db7e915c49674579841c9fdcf06e9ada.png" alt="在这里插入图片描述"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>登陆出现跨域问题有待解决<br><img src="https://img-blog.csdnimg.cn/936d2d4ac3324590976ee3b36915b4d1.png" alt="在这里插入图片描述"></p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>先说说什么是跨域<br>原地址的信息（协议、IP、端口号），与目的地址的信息（协议、IP、端口号）有任何一个对不上都叫跨域<br><img src="https://img-blog.csdnimg.cn/c5f239843490475ea0cabfa0856577df.png" alt="在这里插入图片描述"><br>加入注解，就解决跨域问题可以登陆了<br><img src="https://img-blog.csdnimg.cn/5e00fde04d094df0aad38e4de2a96bb8.png" alt="在这里插入图片描述"></p><h1 id="前端开发（后台）"><a href="#前端开发（后台）" class="headerlink" title="前端开发（后台）"></a>前端开发（后台）</h1><h2 id="讲师页面"><a href="#讲师页面" class="headerlink" title="讲师页面"></a>讲师页面</h2><h3 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h3><p>在路由中添加管理路由<br><img src="https://img-blog.csdnimg.cn/535ce7676c1b42e1a126ae62f8a5aae9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/13128a7990e947bb91eff7ada370c2dd.png" alt="在这里插入图片描述"><br>新建文件，测试一下<br>可以发现，点击不同路由跳转不同页面<br><img src="https://img-blog.csdnimg.cn/89a31649524f4b509aa59874e5dc0d9f.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d66d6249b9fb46f3b493afd9a4589b37.png" alt="在这里插入图片描述"></p><h3 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h3><p>js在专门的API包下单独写，新建出来文件<br><img src="https://img-blog.csdnimg.cn/5d3e6e1182714c84a05ecf1af3009e0d.png" alt="在这里插入图片描述"><br>分页JS<br>路径和请求方式要和后端的请求对应上<br><img src="https://img-blog.csdnimg.cn/cef3f1217d7f48e9a9c979f0e9eb741e.png" alt="在这里插入图片描述"><br>前端${想取的内容} 可以取到想取到的内容，比如公共路径、比如方法参数<br><img src="https://img-blog.csdnimg.cn/6dfe8d6412964f20bf800401db027409.png" alt="在这里插入图片描述"></p><p>回到讲师列表，在样式下方引入script标签<br>把最基本的结构搭建好<img src="https://img-blog.csdnimg.cn/7205049cc9ef4299aa992fc5577af00d.png" alt="在这里插入图片描述"><br>引入数据，函数调用等等内容，完成分页的调用<br>具体的显示样式我这里不做说明，太多了。CV一下<br>页面位置：<code>src\views\vod\teacher\list.vue</code><br>JS位置：<code>src\api\vod\teacher.js</code><br><img src="https://img-blog.csdnimg.cn/f8194cb58ccf428b97c928a55720c8f8.png" alt="在这里插入图片描述"></p><h3 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h3><p>引入组件<br><img src="https://img-blog.csdnimg.cn/65278b77b1af49d2924c3aa0d656f8b3.png" alt="在这里插入图片描述"><br>编写相应的函数，这期间还引入了模糊查询的框等内容，不多赘述了<br><img src="https://img-blog.csdnimg.cn/2ff47a4494f049fa9b9abc2358214017.png" alt="在这里插入图片描述"></p><h4 id="小Bug"><a href="#小Bug" class="headerlink" title="小Bug"></a>小Bug</h4><h5 id="跨域Bug"><a href="#跨域Bug" class="headerlink" title="跨域Bug"></a>跨域Bug</h5><p>后台之前是Login接口加跨域了，Teacher接口没加跨域，记得加一下<br><img src="https://img-blog.csdnimg.cn/d72bfec1ffb74ab89cdf0a11e62d16f3.png" alt="在这里插入图片描述"></p><h5 id="分页Bug"><a href="#分页Bug" class="headerlink" title="分页Bug"></a>分页Bug</h5><p>忘记写MP配置类了，分页分了半天没分出来<br>还以为mp出问题了，结果一看，MP的分页配置类没写<br><img src="https://img-blog.csdnimg.cn/1635bf1ce1314248845b818fb5ddcfd5.png" alt="在这里插入图片描述"><br>蚌埠住了，没写配置类<br><img src="https://img-blog.csdnimg.cn/538500b162264fd1b3e6c5a862554c24.png" alt="在这里插入图片描述"><br>加上配置类就好了<br><img src="https://img-blog.csdnimg.cn/9a905a89b86c4955bd30f9236e0be2c9.png" alt="在这里插入图片描述"></p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>完美解决跨域以及分页问题，功能测试通过<br><img src="https://img-blog.csdnimg.cn/7611295209c142fd87a5b56f9851cb90.png" alt="在这里插入图片描述"></p><h3 id="讲师删除功能"><a href="#讲师删除功能" class="headerlink" title="讲师删除功能"></a>讲师删除功能</h3><p>这里引入ElementUI中的确认弹框，在删除之前进行确认，避免误操作<br>复制的代码我就不在这里赘述了<br><img src="https://img-blog.csdnimg.cn/a3543034aed843bcae6ce5f1603d491b.png" alt="在这里插入图片描述"><br>回到JS文件，把功能补齐<br><img src="https://img-blog.csdnimg.cn/93fc5525857741478912dfdd6a9c0ec9.png" alt="在这里插入图片描述"><br>回到页面，对方法进行调用<br><img src="https://img-blog.csdnimg.cn/c176703ae07e4820adcaf7e5119ebd14.png" alt="在这里插入图片描述"></p><h3 id="讲师添加功能"><a href="#讲师添加功能" class="headerlink" title="讲师添加功能"></a>讲师添加功能</h3><p>先来JS中添加逻辑<br><img src="https://img-blog.csdnimg.cn/9c29ceddcae34393a9d12b89636f9f04.png" alt="在这里插入图片描述"><br>回到讲师添加页面，复制样式进去<br>再把Script标签引入<br><img src="https://img-blog.csdnimg.cn/89ebba7a0972437f9e6c27d1c293c65b.png" alt="在这里插入图片描述"></p><h3 id="讲师修改功能"><a href="#讲师修改功能" class="headerlink" title="讲师修改功能"></a>讲师修改功能</h3><p>修改工程包括修改和数据回显<br>这个跳转页面通过<strong>隐藏路由</strong>来实现<br>也就是看不见那个菜单栏（导航栏），但也可以带着id传递<br>隐藏路由要在路由中添加<br><img src="https://img-blog.csdnimg.cn/697563db5f5a4acf85cdee62c2a52541.png" alt="在这里插入图片描述"><br>教师列表中触发隐藏路由内容<br><img src="https://img-blog.csdnimg.cn/d09f8a739c52445bb224927e1c31bc3f.png" alt="在这里插入图片描述"><br>先写JS的回显功能<br><img src="https://img-blog.csdnimg.cn/4e0476f3dabe447b85981a859b58062b.png" alt="在这里插入图片描述"><br>再写更新操作<br><img src="https://img-blog.csdnimg.cn/a7bab3390c3d4700ae24435d38402f34.png" alt="在这里插入图片描述"></p><p>表单页面<br>页面渲染前获取数据<br><img src="https://img-blog.csdnimg.cn/54473b4187124e609d3036da50aae42f.png" alt="在这里插入图片描述"><br>最后的回显以及保存更新功能<br><img src="https://img-blog.csdnimg.cn/919e7872239146cfa67527d24c2975af.png" alt="在这里插入图片描述"><br>优化保存更新操作</p><p><img src="https://img-blog.csdnimg.cn/2a181c3c8d864a0c9f28e24472d757b3.png" alt="在这里插入图片描述"><br>测试一下，修改成功<br><img src="https://img-blog.csdnimg.cn/1e9cabc8c8d84efc97634fa223208155.png" alt="在这里插入图片描述"></p><h3 id="教师删除操作"><a href="#教师删除操作" class="headerlink" title="教师删除操作"></a>教师删除操作</h3><p>先在JS中定义好批量删除<br><img src="https://img-blog.csdnimg.cn/8a66910b7d954495a8612ba1b839ca2e.png" alt="在这里插入图片描述"><br>初始化组件src&#x2F;views&#x2F;vod&#x2F;teacher&#x2F;list.vue<br>在table组件上添加 <strong>批量删除 按钮</strong><br><img src="https://img-blog.csdnimg.cn/80ffed2bd7aa4bec85bd3de4af259f72.png" alt="在这里插入图片描述"><br>table标签上加入复选框<br><img src="https://img-blog.csdnimg.cn/beae167f35be446a9287b7023624e132.png" alt="在这里插入图片描述"></p><p>在页面中新定义数据，data数组来保存要被删除的id<br><img src="https://img-blog.csdnimg.cn/7f5f19d0528041e2b4f34374014ff473.png" alt="在这里插入图片描述"><br>完善批量删除方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line"><span class="title function_">batchRemove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">multipleSelection</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">warning</span>(<span class="string">&#x27;请选择要删除的记录！&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.$confirm(<span class="string">&#x27;此操作将永久删除该记录, 是否继续?&#x27;</span>, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">    <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 点击确定，远程调用ajax</span></span><br><span class="line">    <span class="comment">// 遍历selection，将id取出放入id列表</span></span><br><span class="line">    <span class="keyword">var</span> idList = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">multipleSelection</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      idList.<span class="title function_">push</span>(item.<span class="property">id</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 调用api</span></span><br><span class="line">    <span class="keyword">return</span> teacherApi.<span class="title function_">batchRemove</span>(idList)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">fetchData</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(response.<span class="property">message</span>)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error === <span class="string">&#x27;cancel&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&#x27;取消删除&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 当多选选项发生变化的时候调用</span></span><br><span class="line"><span class="title function_">handleSelectionChange</span>(<span class="params">selection</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(selection)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">multipleSelection</span> = selection</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以上部分是前端开发过程中的示例，剩下的前端都CV，不自己写了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试课程</title>
      <link href="/2022/10/01/JAVA%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/"/>
      <url>/2022/10/01/JAVA%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="有哪些-Java-优质面试视频推荐？"><a href="#有哪些-Java-优质面试视频推荐？" class="headerlink" title="有哪些 Java 优质面试视频推荐？"></a>有哪些 Java 优质面试视频推荐？</h1><p>文字看累了，还可以看看视频！推荐几个不错的 Java 面试相关的视频。</p><p><strong>1、中华石杉老师的《Java 面试突击第一季》</strong></p><p>即使是19年那会出来的视频，放到现在依然是适用的！对于想要进 Java 生态为主的公司比如美团、阿里非常有帮助！主要讲的是高并发高可用相关的内容。</p><p>地址：<a href="https://www.bilibili.com/video/BV1B4411h7Nz">https://www.bilibili.com/video/BV1B4411h7Nz</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028885295-0a3f1462-ee2d-45fe-b507-e7133a4e29b6.png#clientId=u7b40d553-effc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=357&id=u03de1bdb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=966&originalType=binary&ratio=1&rotation=0&showTitle=false&size=262142&status=done&style=none&taskId=ubdf2ec97-52ac-4650-90b2-920bd075e0a&title=&width=772.8" alt="image.png"></p><p>这份资料对应的笔记：<a href="https://doocs.github.io/advanced-java/#/">https://doocs.github.io/advanced-java/#/</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028936583-9ef64bab-f6ea-4b57-ba1f-83a9454adc74.png#clientId=u7b40d553-effc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=631&id=ua0479cfc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=789&originWidth=941&originalType=binary&ratio=1&rotation=0&showTitle=false&size=324946&status=done&style=none&taskId=u6f6ccb65-b84b-4f15-b631-116e41f076f&title=&width=752.8" alt="image.png"></p><p><strong>2、图灵学院的《Java 常见面试题详解系列》</strong></p><p>涵盖 Java 核心知识、数据库以及常见框架，拿数据库和缓存来说：数据库以面试常问的 MySQL 为例介绍了索引、锁、事务、主从同步、MyISAM 和 InnoDB 的区别、分库分表、慢查询处理等面试题。缓存以面试常问的 Redis 为例介绍了 Redis 常见数据库结构、缓存过期策略、 缓存穿透、缓存击穿、缓存雪崩、数据库和缓存一致性保证、Redis 高可用等面试题。</p><p>地址：<a href="https://www.bilibili.com/video/BV1XU4y1J7Dr">https://www.bilibili.com/video/BV1XU4y1J7Dr</a></p><p><strong>3、尚硅谷周阳老师的 《Java 面试题第三季》</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028903655-b1db0e8d-e613-44e7-8f0f-171d85ce52d1.png#clientId=u7b40d553-effc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=u2b17c5e5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=1033&originalType=binary&ratio=1&rotation=0&showTitle=false&size=184517&status=done&style=none&taskId=udfe3cf33-3acf-49b9-8b50-be0113dc69f&title=&width=826.4" alt="image.png"></p><p>Java 培训领域比较出名的周阳老师的作品，内容涵盖算法、Java 核心知识、数据库以及常见框架。</p><p>可以重点看看并发和 Spring 这块，比其他老师讲的要深入和好理解很多。</p><p>地址：<a href="https://www.bilibili.com/video/BV1Hy4y1B78T">https://www.bilibili.com/video/BV1Hy4y1B78T</a></p><p><strong>前两季视频地址</strong> ：</p><p>● Java 面试题第一季 ：<a href="https://www.bilibili.com/video/BV1Eb411P7bP">https://www.bilibili.com/video/BV1Eb411P7bP</a><br>● Java 面试题第二季 ：<a href="https://www.bilibili.com/video/BV18b411M7xz">https://www.bilibili.com/video/BV18b411M7xz</a></p><p><strong>4、图灵的《分布式面试核心面试题系列》</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028916188-5694f554-b265-4902-85b8-517c5b13bdbf.png#clientId=u7b40d553-effc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u4f040e7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=983&originalType=binary&ratio=1&rotation=0&showTitle=false&size=184993&status=done&style=none&taskId=u1cef61e9-a63d-4036-9c9c-9781c3edcfa&title=&width=786.4" alt="image.png"></p><p>主要是分布式相关的内容，涵盖负载均衡、分布式 ID、分布式事务、Dubbo、Zookeeper 、Redis。</p><p>地址：<a href="https://www.bilibili.com/video/BV1Mz4y1Z7bM">https://www.bilibili.com/video/BV1Mz4y1Z7bM</a></p><p><strong>5、享学的《Java 面试全解析系列》</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028947744-053fc68b-2701-41ce-b8d8-b2ee0270a06c.png#clientId=u7b40d553-effc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=331&id=uf2e40fb1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=414&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188352&status=done&style=none&taskId=ubf0b3479-d6a0-46cf-8da3-3995a5d1c25&title=&width=760.8" alt="image.png"></p><p>内容比较杂，可以挑选自己比较感兴趣面试题学习。可以重点看看数据库这块，对于常见的 MySQL 面试题比如 MySQL 索引数据结构介绍的比较详细。</p><p>地址：<a href="https://www.bilibili.com/video/BV1yA411u7WL">https://www.bilibili.com/video/BV1yA411u7WL</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有哪些优质 Java 实战项目推荐？</title>
      <link href="/2022/10/01/%E4%BC%98%E8%B4%A8JAVA%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/10/01/%E4%BC%98%E8%B4%A8JAVA%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>开源项目</strong></p><p><strong>社区</strong></p><p><a href="https://t.zsxq.com/zb2fMzr">upupor</a> 是一个小众但是功能强大，代码质量也还可以的开源社区，挺适合作为学习的项目。 最主要的是这个项目目前知名度非常非常低，没有项目经历的小伙伴也可以改造升级一下拿来作为自己的项目经历。</p><p>Github 地址：<a href="https://github.com/yangrunkang/upupor">https://github.com/yangrunkang/upupor</a> 。</p><p>技术栈：</p><p>●后端：Spring Boot + MySQL + Redis + Undertow（Web容器）<br>●前端 ：Thymeleaf（模板引擎，方便 SEO）+ Bootstrap</p><p>在线演示：<a href="https://upupor.com/">https://upupor.com</a> 。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028300855-0e490da2-b6b9-40c6-b298-7f50b7ff891c.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9b1d55ed&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1221&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137630&status=done&style=none&taskId=u12041505-345d-4b45-a30f-26a4c174e37&title=" alt="1.png"></p><p>网站的性能也是不错的：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028323294-52009511-0d7f-4bd5-b8da-21fe319d3fed.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf50c62fa&margin=%5Bobject%20Object%5D&name=1.png&originHeight=843&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42592&status=done&style=none&taskId=ud1d6a456-ee89-4e02-8a72-131226336fd&title=" alt="1.png"></p><p>类似的社区类小众但有两点的项目还有 <a href="https://github.com/rymcu/forest">forest</a>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028342800-cfd0f07b-92bf-4afb-b454-89698f361903.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc026e41b&margin=%5Bobject%20Object%5D&name=1.png&originHeight=285&originWidth=1248&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23419&status=done&style=none&taskId=uaf693339-3001-4e8c-8b12-7e14445d2c6&title=" alt="1.png"></p><p>不同于其他社区项目，forest 这个知识社区项目主打文章分享，可以自定义专题和作品集。看得出来作者维护比较认真，并且很有想法。根据项目首页介绍，这个项目未来还可能会增加专业知识题库、社区贡献系统、会员系统。</p><p>我大概浏览了一下这个项目代码，发现这个项目的代码写的也相对比较规范干净，比很多 star 数量比较多的社区类项目都要好太多！</p><p>Github 地址：<a href="https://github.com/rymcu">https://github.com/rymcu</a> 。</p><p>技术栈：</p><p>●后端： SpringBoot + Shrio + MyBatis + JWT + Redis<br>●前端：Vue + NuxtJS + Element-UI。</p><p>在线演示：<a href="https://rymcu.com/">https://rymcu.com/</a> 。</p><p><strong>小说网站</strong></p><p><a href="https://t.zsxq.com/iufIi2R">novel-plus</a> 是一个开源的小说网站项目。这个项目的代码质量也是非常不错的，结果清晰，代码结构也比较规范。这是我推荐这个项目很大的一个原因。</p><p>●Github 地址：<a href="https://github.com/201206030/novel-plus">https://github.com/201206030/novel-plus</a><br>●Gitee 地址：<a href="https://gitee.com/novel_dev_team/novel-plus">https://gitee.com/novel_dev_team&#x2F;novel-plus</a></p><p>另外，除了单体版之外，这个项目还有一个基于 Spring Cloud 的微服务版本供你学习使用。</p><p>●GitHub 地址： <a href="https://github.com/201206030/novel-cloud">https://github.com/201206030/novel-cloud</a><br>●Gitee 地址： <a href="https://gitee.com/novel_dev_team/novel-cloud">https://gitee.com/novel_dev_team&#x2F;novel-cloud</a></p><p>技术栈：</p><p>●后端： SpringBoot + MyBatis +Spring Security + Elasticsearch+ 支付宝支付<br>●前端：Thymeleaf + Layui。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028367799-dfc76d78-bec1-4fcf-8939-008129bd0a20.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=442&id=u41ff1b65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=260627&status=done&style=none&taskId=ude180500-c5f3-4609-8aad-08c8032a7ca&title=&width=764.8" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028374627-6685421c-90d0-424f-a36f-4aa4be08013f.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=386&id=ub6d31d3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179684&status=done&style=none&taskId=uffac6210-08d7-4ad8-889e-4f965b8569b&title=&width=813.6" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028379941-674f3f80-19fc-4526-8fe0-32bf476f2ca6.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u47330456&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103597&status=done&style=none&taskId=u104583c1-4223-4f77-8414-be1d78670ef&title=&width=765.6" alt="image.png"><br>这个项目还有一个爬虫模块用于系统初期测试使用。对Java爬虫感兴趣的朋友，可以简单研究一下。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028385662-2b61bff1-7895-4e5b-bb92-b0c6e2328bc9.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=ua1aecfaf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=434&originWidth=573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58677&status=done&style=none&taskId=u7dbf3ae1-c9dd-4239-b5d1-a949a171a22&title=&width=458.4" alt="image.png"></p><p><strong>本地缓存</strong></p><p><a href="https://t.zsxq.com/RfyRrrv">cache</a> 是一个不错的轮子类项目，使用 Java 手写一个类似于 Redis 的单机版本地缓存(附详细教程)。 麻雀虽小五张俱全，支持数据缓存、缓存失效时间、数据淘汰策略（如FIFO 、 LRU ）、RDB 和 AOF 持久化……。 并且，这个项目附带了 6 篇教程来讲解核心功能具体是怎么实现的。</p><p>Github地址：<a href="https://github.com/houbb/cache">https://github.com/houbb/cache</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028398127-bf1b790d-a3e4-4415-b06f-13282cd3bbbd.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=565&id=uc0a59e98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=987&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190942&status=done&style=none&taskId=uc85a67a4-a532-4a5f-a626-7a985149de0&title=&width=789.6" alt="image.png"></p><p><strong>导航网站</strong></p><p><a href="https://t.zsxq.com/FEYBYbU">geshanzsq-nav</a> 是一个前后端分离的导航网站。这个项目同样非常小众，撞车的概率非常小，并且，质量也是非常高。</p><p>●Github 地址：<a href="https://github.com/geshanzsq/geshanzsq-nav">https://github.com/geshanzsq/geshanzsq-nav</a><br>●Gitee 地址 ：<a href="https://gitee.com/geshanzsq/geshanzsq-nav">https://gitee.com/geshanzsq/geshanzsq-nav</a></p><p>技术栈：</p><p>●后端： SpringBoot + MyBatis +Spring Security + Spring Security + Redis + Jwt<br>●前端：Thymeleaf + Layui。</p><p>在线演示：<a href="https://gesdh.cn/">https://gesdh.cn/</a> 。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028409192-536245ce-2286-4f68-b25e-756a37834fdb.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=531&id=u9086e336&margin=%5Bobject%20Object%5D&name=image.png&originHeight=664&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&size=196059&status=done&style=none&taskId=u835ccd18-d2c5-4228-abe2-7349910daa9&title=&width=785.6" alt="image.png"></p><p><strong>音乐网站</strong></p><p><a href="https://t.zsxq.com/YfqVzrV">music-website</a> 是一个开源的音乐网站。这个项目的前端写的挺不错的，后端稍微差劲很多，虽然也把功能写出来了，但是很多实现都不太优雅（详见 Controller 层）。</p><p>如果你想要将这个项目作为自己的项目经验或者毕业设计的话，可以自行对后端的代码进行优化。</p><p>Github 地址：<a href="https://github.com/Yin-Hongwei/music-website">https://github.com/Yin-Hongwei/music-website</a> 。</p><p>技术栈：</p><p>●后端 ：SpringBoot + MyBatis + MySQL<br>●前端 ：Vue3.0 + TypeScript + Vue-Router + Vuex + Axios + ElementPlus + Echarts</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028417074-36dd77de-b347-4f8e-9c87-c43486011e00.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=430&id=u25fb31ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=546742&status=done&style=none&taskId=u737a3ee5-4e6e-4f5f-a9e0-31e0450a40b&title=&width=769.6" alt="image.png"></p><p><strong>RPC框架</strong></p><p>guide-rpc-framework 是一款基于 Netty+Kyro+Zookeeper 实现的 RPC 框架。</p><p>●Github 地址:  <a href="https://github.com/Snailclimb/guide-rpc-framework">https://github.com/Snailclimb/guide-rpc-framework</a><br>●Gitee 地址 ：<a href="https://gitee.com/SnailClimb/guide-rpc-framework">https://gitee.com/SnailClimb/guide-rpc-framework</a></p><p>这个项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028452393-e6f7318c-49e2-4508-8904-97b346221f81.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u811d1494&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1426&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&size=955298&status=done&style=none&taskId=u95c11c69-7c90-4eb3-befb-89afc033da6&title=" alt="1.png"></p><p>并且，这个项目的 README 文档写的也非常认真。从 README 文档中，你就可以大概了解到这个 RPC 框架的设计思路以及前置技术。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22521494/1650028479905-c72d3f64-44f4-440f-9c9b-e3066d3843bb.png#clientId=udb5327c9-266e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4ab2c383&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1852&originWidth=914&originalType=binary&ratio=1&rotation=0&showTitle=false&size=562303&status=done&style=none&taskId=uc88a9773-0ecf-4cd8-9e3f-10c17233c73&title=" alt="1.png"></p><p><strong>视频</strong></p><p>大家有没有比较好的实战项目视频分享推荐下？慕课网上面的实战课程虽然多，但是，说实话哈，有一些质量都不过关，价格也不便宜。求球友分享优质的实战项目视频教程。</p><p>●<a href="https://mp.weixin.qq.com/s/B-Gzw20xKIPC_w4b_8bJiA">电商系统 &amp; 金融系统</a><br>●<a href="https://t.zsxq.com/zFIAubi">在线教育系统 &amp; 预约挂号系统 &amp; 云原生实战</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.4遇到的问题</title>
      <link href="/2022/10/01/ubuntu18.4%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/01/ubuntu18.4%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>初始安装时：<img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1649304979905-181ce88c-17dd-425f-8b1e-13b531557098.png#clientId=u6d078e06-09ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=u173ba25a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58134&status=done&style=none&taskId=uc6b10b8f-fa7a-4039-b897-e7b3fd08db6&title=&width=710" alt="image.png"><br>启用NAT网络设置：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1649305053308-9c55a28a-1841-465b-8cdf-70848063d8e3.png#clientId=u6d078e06-09ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=625&id=u3a7a2cf4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149970&status=done&style=none&taskId=u3e580369-beb2-48bb-8621-b3f41bdd9a5&title=&width=813.3333333333334" alt="image.png"></p><h2 id="修改更新源"><a href="#修改更新源" class="headerlink" title="修改更新源"></a>修改更新源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#先备份</span><br><span class="line">sudo cp  /etc/apt/sources.<span class="built_in">list</span>  /etc/apt/sources.<span class="built_in">list</span>.backup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo gedit /etc/apt/sources.<span class="built_in">list</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># sources.list </span></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src http:<span class="comment">//mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进程被占用"><a href="#进程被占用" class="headerlink" title="进程被占用"></a>进程被占用</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1649305683825-c6bb94ed-8d68-4560-8caf-673e9a0fc31b.png#clientId=u6d078e06-09ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=197&id=u6771a94c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=852&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105522&status=done&style=none&taskId=u7f5b336d-ba36-4090-bf11-c8aea63e928&title=&width=568" alt="image.png"></p><h2 id="网络问题："><a href="#网络问题：" class="headerlink" title="网络问题："></a>网络问题：</h2><p>桥接模式失效，无奈启用NAT模式</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1649305799140-6fab699d-18a6-4f7d-955c-e23797c3a945.png#clientId=u6d078e06-09ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u64cf7bda&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75929&status=done&style=none&taskId=u6711d50f-4fc4-4443-a3d2-c3025c64ead&title=&width=686.6666666666666" alt="image.png"></p><p>使用nmcli，该命令可以完成网卡上所有的配置工作，并且可以写入配置文件，永久生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nmcli networking off</span><br><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure><p>最简单操作–&gt;终端直接运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager restart</span><br></pre></td></tr></table></figure><h3 id="如未解决请继续往下看"><a href="#如未解决请继续往下看" class="headerlink" title="如未解决请继续往下看"></a>如未解决请继续往下看</h3><p>1.虚拟机使用Ubuntu 18.04时,网络图标总消失,查询各种方法后,自己总结下以备己用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service network-manager start</span><br><span class="line"></span><br><span class="line">sudo gedit /etc/NetworkManager/NetworkManager.conf</span><br><span class="line">把<span class="literal">false</span>改成<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">sudo service network-manager restart</span><br></pre></td></tr></table></figure><p><strong>2.当然了</strong>,如果想windows接入了互联网,也要把虚拟机的网络适配器配置为NAT(Network Address Translation)模式,Ubuntu才能访问互联网.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1649305053308-9c55a28a-1841-465b-8cdf-70848063d8e3.png#clientId=u6d078e06-09ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=625&id=QJX3Z&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149970&status=done&style=none&taskId=u3e580369-beb2-48bb-8621-b3f41bdd9a5&title=&width=813.3333333333334" alt="image.png"></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>加入环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 指定文件或者目录</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows应用搬家</title>
      <link href="/2022/10/01/Windows%E5%BA%94%E7%94%A8%E6%90%AC%E5%AE%B6/"/>
      <url>/2022/10/01/Windows%E5%BA%94%E7%94%A8%E6%90%AC%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>软件清单</p><ul><li>语雀</li><li>utools  | everything </li><li>git</li><li>node.js</li><li>java  IDEA   |  VScode</li><li>python   | pycharm</li><li>Edge浏览器</li><li>WPS</li><li>PDF-XChange Pro</li><li>HBuilder </li><li>hexo-editor</li><li>火绒安全</li><li>IDM</li><li>Microsoft Office Visio</li><li>边写边搜</li><li>Anaconda</li><li>CAJViewer   知网研学</li><li>feishu</li><li>todesk</li><li>centos</li><li>Clash for Windows</li><li>阿里云盘</li><li>百度网盘</li><li>CNKI E-Study</li><li>EndNote</li><li>飞书</li><li>FormatFactory</li><li>qq  |  tim | 微信  | 微信小程开发工具  | **小程序开发工具</li><li>Snipaste</li><li>VMware Player</li><li>Wise Program Uninstaller</li><li>Xshell6</li><li>百度翻译 | 网易云翻译</li><li>钉钉</li><li>剪映</li><li>超星阅读器</li><li>腾讯桌面管家 |  腾讯会议</li><li>向日葵</li><li>知云文献翻译</li><li>7z | 格式工厂</li><li>sspacesniffer</li><li>WindowsTabs</li><li>winrar</li><li>搜狗输入法</li><li>Snipaste   截图工具</li><li>WinSCP</li><li>Apifox   <a href="https://www.apifox.cn/">https://www.apifox.cn/</a></li><li>MobaXterm :</li><li>方方格子</li><li>Screen to Gif</li><li>洛雪音乐助手</li><li>Termius</li></ul><p>HBuilderProjects<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1143997/1642433039793-749629a9-cf4e-4ebf-925d-3533308bc3a1.png#clientId=u888b0383-8a95-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=u7b65ca38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61566&status=done&style=none&taskId=u41d30b2a-a711-42a4-96b8-0c77b1fde3f&title=&width=271.5" alt="image.png"></p><p>7-Zip<br><a href="https://sparanoid.com/lab/7z/">https://sparanoid.com/lab/7z/</a> </p><p>Geek Uninstaller<br><a href="https://geekuninstaller.com/">https://geekuninstaller.com/</a></p><p>Microsoft Edge<br><a href="https://www.microsoft.com/en-us/edge">https://www.microsoft.com/en-us/edge</a></p><p>PotPlayer<br><a href="https://potplayer.daum.net/?lang=zh_CN">https://potplayer.daum.net/?lang=zh_CN</a></p><p>IDM<br><a href="http://www.internetdownloadmanager.com/">http://www.internetdownloadmanager.com/</a></p><p>Clover<br><a href="http://cn.ejie.me/">http://cn.ejie.me/</a></p><p>CCleaner<br><a href="https://www.ccleaner.com/">https://www.ccleaner.com/</a> </p><p>Wox<br><a href="https://github.com/Wox-launcher/Wox/releases">https://github.com/Wox-launcher/Wox/releases</a></p><p>Everything<br><a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><p>utools<br><a href="http://www.u.tools/">http://www.u.tools/</a></p><h2 id="Potplayer"><a href="#Potplayer" class="headerlink" title="Potplayer"></a>Potplayer</h2><p><a href="https://www.yuque.com/attachments/yuque/0/2022/rar/1143997/1651664828226-96bbfcb8-38ef-4289-a5a9-7fc8b9ed72d4.rar?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/rar/1143997/1651664828226-96bbfcb8-38ef-4289-a5a9-7fc8b9ed72d4.rar%22,%22name%22:%22Setup64.rar%22,%22size%22:30152210,%22type%22:%22%22,%22ext%22:%22rar%22,%22source%22:%22%22,%22status%22:%22done%22,%22mode%22:%22title%22,%22download%22:true,%22taskId%22:%22uff279b6b-19fc-42eb-826e-9d21f4947a2%22,%22taskType%22:%22transfer%22,%22id%22:%22u1c6b03e6%22,%22card%22:%22file%22%7D">Setup64.rar</a><br><a href="https://www.yuque.com/attachments/yuque/0/2022/zip/1143997/1651664828223-c9b490f9-5793-4643-8c15-2b0d02788399.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/zip/1143997/1651664828223-c9b490f9-5793-4643-8c15-2b0d02788399.zip%22,%22name%22:%22Skins%E7%9A%AE%E8%82%A4.zip%22,%22size%22:5338989,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22source%22:%22%22,%22status%22:%22done%22,%22mode%22:%22title%22,%22download%22:true,%22taskId%22:%22ue1be1d46-af16-46e0-925a-aab1af00250%22,%22taskType%22:%22transfer%22,%22id%22:%22u3a8edb0a%22,%22card%22:%22file%22%7D">Skins皮肤.zip</a><br><a href="https://www.yuque.com/attachments/yuque/0/2022/rar/1143997/1651664828231-f1496e9c-be9a-4e1f-84ff-1894820d764c.rar?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/rar/1143997/1651664828231-f1496e9c-be9a-4e1f-84ff-1894820d764c.rar%22,%22name%22:%22%E7%9B%B4%E6%92%AD%E6%BA%90.rar%22,%22size%22:374484,%22type%22:%22%22,%22ext%22:%22rar%22,%22source%22:%22%22,%22status%22:%22done%22,%22mode%22:%22title%22,%22download%22:true,%22taskId%22:%22u69170b4f-7487-4133-b2a8-02e8ec34768%22,%22taskType%22:%22transfer%22,%22id%22:%22u14142651%22,%22card%22:%22file%22%7D">直播源.rar</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共产党宣言</title>
      <link href="/2022/10/01/%E3%80%8A%E5%85%B1%E4%BA%A7%E5%85%9A%E5%AE%A3%E8%A8%80%E3%80%8B/"/>
      <url>/2022/10/01/%E3%80%8A%E5%85%B1%E4%BA%A7%E5%85%9A%E5%AE%A3%E8%A8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="共产党宣言"><a href="#共产党宣言" class="headerlink" title="共产党宣言"></a>共产党宣言</h1><p>一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。</p><p>有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？</p><p>从这一事实中可以得出两个结论：</p><p>共产主义已经被欧洲的一切势力公认为一种势力；</p><p>现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。</p><p>为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p><h2 id="一、资产者和无产者"><a href="#一、资产者和无产者" class="headerlink" title="一、资产者和无产者"></a>一、资产者和无产者</h2><p>至今一切社会的历史都是阶级斗争的历史。</p><p>自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局都是整个社会受到革命改造或者斗争的各阶级同归于尽。</p><p>在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p><p>从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p><p>但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p><p>从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p><p>美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p><p>以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p><p>但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业代替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p><p>大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展。同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级排挤到后面去。</p><p>由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p><p>资产阶级的这种发展的每一个阶段，都伴随着相应的政治上的进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p><p>资产阶级在历史上曾经起过非常革命的作用。</p><p><strong>资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</strong></p><p>资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p><p>资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p><p>资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军征讨的远征。</p><p>资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p><p>不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p><p>资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠本国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p><p><strong>资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓的文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</strong></p><p>资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正像它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p><p>资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p><p>资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p><p>由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，它已经被炸毁了。</p><p>起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p><p>现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。<strong>在危机期间，发生一种在过去一切时代看来都好像是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。</strong><br>资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——<strong>资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。</strong><br>这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p><p>资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p><p>但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p><p><strong>随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其他任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</strong></p><p>由于推广机器和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，<strong>花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。</strong><br>但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。<br><strong>因此，劳动越使人感到厌恶，工资也就越少。</strong><br>不仅如此，机器越推广，分工越细致，劳动量出就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p><p>现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就像士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。<br><strong>他们不仅仅是资产阶级的、资产阶级国家的奴隶，他们每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。</strong><br>这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p><p>手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。<br><strong>对工人阶级来说，性别和年龄的差别再没有什么社会意义了。</strong><br>他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p><p>当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p><p>以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大的资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级就是这样从居民的所有阶级中得到补充的。</p><p>无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p><p>最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p><p>在这个阶段上，工人是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产者和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p><p>但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益、生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p><p>工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p><p>无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p><p>旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族；后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。<strong>在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</strong></p><p>其次，我们已经看到，工业的进步把统治阶级的整批成员抛到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p><p>最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p><p>在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p><p>中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p><p><strong>流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</strong></p><p>在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p><p>过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p><p>过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p><p>如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p><p>在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p><p>我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社成员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当作支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生存下去了，就是说，它的生存不再同社会相容了。</p><p>资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p><p>二、无产者和共产党人</p><p>共产党人同全体无产者的关系是怎样的呢？</p><p>共产党人不是同其他工人政党相对立的特殊政党。</p><p>他们没有任何同整个无产阶级的利益不同的利益。</p><p>他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p><p>共产党人同其他无产阶级政党不同的地方只是：一方面，在无产者不同的民族的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><p>因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p><p>共产党人的最近目的是和其他一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p><p>共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p><p>这些原理不过是现存的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p><p>一切所有制关系都经历了经常的历史更替、经常的历史变更。</p><p>例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p><p>共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p><p>但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又完备的表现。</p><p>从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p><p>有人责备我们共产党人，说我们消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p><p>好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级财产出现以前的那种小资产阶级、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p><p>或者，你们说的是现代的资产阶级的私有财产吧？</p><p>但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增殖的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p><p>做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p><p>因此，资本不是一种个人力量，而是一种社会力量。</p><p>因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这里所改变的只是财产的社会性质。它将失掉它的阶级性质。</p><p>现在，我们来看看雇佣劳动。</p><p>雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p><p>在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p><p>因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p><p>而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p><p>在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p><p>但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也像我们的资产阶级的其他一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p><p>我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p><p>总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p><p>从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性被消灭了。</p><p>由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p><p>共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p><p>有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p><p>这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里劳者不获，获者不劳。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p><p>所有这些对共产主义的物质产品的占有方式和生产方式的责备，也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p><p>资产者唯恐失去的那种教育，绝大多数人来说是把人训练成机器。</p><p>但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正像你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件决定的。</p><p>你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p><p>消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p><p><strong>现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</strong></p><p>资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p><p>你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p><p>但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p><p><strong>而你们的教育不也是由社会决定的吗？不也是由你们进行教育时所处的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的作用；他们仅仅是要改变这种作用的性质，要使教育摆脱统治阶级的影响。</strong></p><p>无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p><p>但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p><p>资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p><p>他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p><p>其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p><p>我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p><p><strong>资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</strong></p><p>有人还责备共产党人，说他们要取消祖国，取消民族。</p><p>工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p><p>随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族分隔和对立日益消失。</p><p>无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p><p>人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p><p>民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p><p>从宗教的、哲学的和一切意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p><p>人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p><p>思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p><p>当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p><p><strong>当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明竞争在信仰领域里占统治地位罢了。</strong></p><p>“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p><p>此外，还存在着一切社会状态所共有的永恒真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展相矛盾的。”</p><p>这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在不同的时代具有不同的形式。</p><p>但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p><p>共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p><p>不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p><p>前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p><p>无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p><p>要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p><p>这些措施在不同的国家里当然会是不同的。</p><p>**但是，最先进的国家几乎都可以采取下面的措施：</p><p><strong>1、剥夺地产，把地租用于国家支出。</strong></p><p><strong>2、征收高额累进税。</strong></p><p><strong>3、废除继承权。</strong></p><p><strong>4、没收一切流亡分子和叛乱分子的财产。</strong></p><p><strong>5、通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</strong></p><p><strong>6、把全部运输业集中在国家的手里。</strong></p><p><strong>7、按照总的计划增加国家工厂和生产工具，开垦荒地和改良土壤。</strong></p><p><strong>8、实行普遍劳动义务制，成立产业军，特别是在农业方面。</strong></p><p><strong>9、把农业和工业结合起来，促使城乡对立逐步消灭。</strong></p><p><strong>10、对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</strong></p><p>当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立的存在条件，消灭阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p><p>代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p><h2 id="三、社会主义的和共产主义的文献"><a href="#三、社会主义的和共产主义的文献" class="headerlink" title="三、社会主义的和共产主义的文献"></a>三、社会主义的和共产主义的文献</h2><h3 id="1．反动的社会主义"><a href="#1．反动的社会主义" class="headerlink" title="1．反动的社会主义"></a>1．反动的社会主义</h3><h4 id="（甲）封建的社会主义"><a href="#（甲）封建的社会主义" class="headerlink" title="（甲）封建的社会主义"></a>（甲）封建的社会主义</h4><p>法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模作样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。</p><p>这样就产生了封建的社会主义，半是挽歌，半是谤文，半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论剌中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。</p><p>为了拉拢人民，贵族们把无产阶级的乞食袋当作旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。</p><p>一部分法国正统派和“青年英国”，都演过这出戏。</p><p>封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。</p><p>不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。</p><p>他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。</p><p>因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧洒的买卖。</p><p>正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。</p><p>要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有财产，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣的圣水罢了。</p><h4 id="（乙）小资产阶级的社会主义"><a href="#（乙）小资产阶级的社会主义" class="headerlink" title="（乙）小资产阶级的社会主义"></a>（乙）小资产阶级的社会主义</h4><p>封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。</p><p>在现代文明已经发展的国家里，形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争抛到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。</p><p>在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。</p><p>这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。</p><p>但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。</p><p>工业中的行会制度，农业中的宗法经济，——这就是它的结论。</p><p>这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p><h4 id="（丙）德国的或“真正的”社会主义"><a href="#（丙）德国的或“真正的”社会主义" class="headerlink" title="（丙）德国的或“真正的”社会主义"></a>（丙）德国的或“真正的”社会主义</h4><p>法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。</p><p>德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹的意志、本来的意志、真正人的意志的规律。</p><p>德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。</p><p>这种掌握，就像掌握外国语一样，是通过翻译的。</p><p>大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。</p><p>这种在法国人的论述下面塞进自己哲学词句的做法，他们称之为“行动的哲学”、”真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。</p><p>法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。</p><p>这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。</p><p>德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。</p><p>于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判（德国的社会主义是这种批判的可怜的回声）是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。</p><p>这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。</p><p>这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。</p><p>既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。</p><p>保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义像瘟疫一样流行起来了。</p><p>德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。</p><p>同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。</p><p>它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚地超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p><h3 id="2．保守的或资产阶级的社会主义"><a href="#2．保守的或资产阶级的社会主义" class="headerlink" title="2．保守的或资产阶级的社会主义"></a>2．保守的或资产阶级的社会主义</h3><p>资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。</p><p>这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。</p><p>我们可以举蒲鲁东的《贫困的哲学》作为例子。</p><p>社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要抛弃他们关于这个社会的可恶的观念。</p><p>这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的废除，而是一些在这种生产关系的基础上实行的行政上的改良，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。</p><p>资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。</p><p>自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。</p><p>资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p><h3 id="3．批判的空想的社会主义和共产主义"><a href="#3．批判的空想的社会主义和共产主义" class="headerlink" title="3．批判的空想的社会主义和共产主义"></a>3．批判的空想的社会主义和共产主义</h3><p>在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献（巴贝夫等人的著作）。</p><p>无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p><p>本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了（见《资产阶级和无产阶级》）。</p><p>诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p><p>由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p><p>社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由一种特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p><p>诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们心目中，无产阶级只是一个受苦最深的阶级。</p><p>但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p><p>因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p><p>这种对未来社会的幻想的描绘，在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，是同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p><p>但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p><p>批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p><p>因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p><p>在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p><h2 id="四、共产党人对各种反对党派的态度"><a href="#四、共产党人对各种反对党派的态度" class="headerlink" title="四、共产党人对各种反对党派的态度"></a>四、共产党人对各种反对党派的态度</h2><p>看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p><p>共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p><p>在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p><p>在波兰人中间，共产党人支持那个把土地革命当作民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p><p>在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p><p>但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p><p>共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p><p>总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p><p>在所有这些运动中，他们都强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p><p>最后，共产党人到处都努力争取全世界民主政党之间的团结和协调。</p><p>共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p><p><strong>全世界无产者，联合起来！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

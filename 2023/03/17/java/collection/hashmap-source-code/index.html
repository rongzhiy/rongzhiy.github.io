<!DOCTYPE html><html lang="zh-CN" data-theme="bright"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HashMap源码&amp;底层数据结构分析 | Rongzhiyのblog</title><meta name="keywords" content="Java集合"><meta name="author" content="阿泽"><meta name="copyright" content="阿泽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="感谢 changfubai 对本文的改进做出的贡献！  HashMap 简介HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。  HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashM">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码&amp;底层数据结构分析">
<meta property="og:url" content="https://rongzhiy.github.io/2023/03/17/java/collection/hashmap-source-code/index.html">
<meta property="og:site_name" content="Rongzhiyのblog">
<meta property="og:description" content="感谢 changfubai 对本文的改进做出的贡献！  HashMap 简介HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。  HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzxjyanj30yq0oewpe.jpg">
<meta property="article:published_time" content="2023-03-17T08:59:52.707Z">
<meta property="article:modified_time" content="2023-03-16T07:55:48.000Z">
<meta property="article:author" content="阿泽">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzxjyanj30yq0oewpe.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rongzhiy.github.io/2023/03/17/java/collection/hashmap-source-code/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-16 15:55:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Rongzhiyのblog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">HashMap源码&amp;底层数据结构分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T08:59:52.707Z" title="发表于 2023-03-17 16:59:52">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-16T07:55:48.000Z" title="更新于 2023-03-16 15:55:48">2023-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HashMap源码&amp;底层数据结构分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>感谢 <a target="_blank" rel="noopener" href="https://github.com/changfubai">changfubai</a> 对本文的改进做出的贡献！</p>
</blockquote>
<h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p>
<p> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<pre><code class="java">    static final int hash(Object key) &#123;
      int h;
      // key.hashCode()：返回散列值也就是hashcode
      // ^ ：按位异或
      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
  &#125;
</code></pre>
<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<pre><code class="java">static int hash(int h) &#123;
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
&#125;
</code></pre>
<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png" alt="jdk1.8 之前的内部结构-HashMap"></p>
<h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png" alt="jdk1.8之后的内部结构-HashMap"></p>
<p><strong>类的属性：</strong></p>
<pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;
    // 序列号
    private static final long serialVersionUID = 362498820763181265L;
    // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
    // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8;
    // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6;
    // 桶中结构转化为红黑树对应的table的最小容量
    static final int MIN_TREEIFY_CAPACITY = 64;
    // 存储元素的数组，总是2的幂次倍
    transient Node&lt;k,v&gt;[] table;
    // 存放具体元素的集
    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    // 存放元素的个数，注意这个不等于数组的长度。
    transient int size;
    // 每次扩容和更改map结构的计数器
    transient int modCount;
    // 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容
    int threshold;
    // 加载因子
    final float loadFactor;
&#125;
</code></pre>
<ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p><strong>Node 节点类源码:</strong></p>
<pre><code class="java">// 继承自 Map.Entry&lt;K,V&gt;
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较
       final K key;//键
       V value;//值
       // 指向下一个节点
       Node&lt;K,V&gt; next;
       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        &#125;
        public final K getKey()        &#123; return key; &#125;
        public final V getValue()      &#123; return value; &#125;
        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;
        // 重写hashCode()方法
        public final int hashCode() &#123;
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        &#125;

        public final V setValue(V newValue) &#123;
            V oldValue = value;
            value = newValue;
            return oldValue;
        &#125;
        // 重写 equals() 方法
        public final boolean equals(Object o) &#123;
            if (o == this)
                return true;
            if (o instanceof Map.Entry) &#123;
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            &#125;
            return false;
        &#125;
&#125;
</code></pre>
<p><strong>树节点类源码:</strong></p>
<pre><code class="java">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;
        TreeNode&lt;K,V&gt; parent;  // 父
        TreeNode&lt;K,V&gt; left;    // 左
        TreeNode&lt;K,V&gt; right;   // 右
        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
        boolean red;           // 判断颜色
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;
            super(hash, key, val, next);
        &#125;
        // 返回根节点
        final TreeNode&lt;K,V&gt; root() &#123;
            for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;
                if ((p = r.parent) == null)
                    return r;
                r = p;
       &#125;
</code></pre>
<h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p>
<pre><code class="java">    // 默认构造函数。
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted
     &#125;

     // 包含另一个“Map”的构造函数
     public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);//下面会分析到这个方法
     &#125;

     // 指定“容量大小”的构造函数
     public HashMap(int initialCapacity) &#123;
         this(initialCapacity, DEFAULT_LOAD_FACTOR);
     &#125;

     // 指定“容量大小”和“加载因子”的构造函数
     public HashMap(int initialCapacity, float loadFactor) &#123;
         if (initialCapacity &lt; 0)
             throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
         if (initialCapacity &gt; MAXIMUM_CAPACITY)
             initialCapacity = MAXIMUM_CAPACITY;
         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
             throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
         this.loadFactor = loadFactor;
         this.threshold = tableSizeFor(initialCapacity);
     &#125;
</code></pre>
<p><strong>putMapEntries 方法：</strong></p>
<pre><code class="java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;
    int s = m.size();
    if (s &gt; 0) &#123;
        // 判断table是否已经初始化
        if (table == null) &#123; // pre-size
            // 未初始化，s为m的实际元素个数
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                    (int)ft : MAXIMUM_CAPACITY);
            // 计算得到的t大于阈值，则初始化阈值
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        &#125;
        // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s &gt; threshold)
            resize();
        // 将m中的所有元素添加至HashMap中
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>
<p><strong>对 putVal 方法添加元素的分析如下：</strong></p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put%E6%96%B9%E6%B3%95.png" alt=" "></p>
<p>说明:上图有两个小问题：</p>
<ul>
<li>直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/608">issue#608</a>）。</li>
<li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 <code>treeifyBin()</code> 方法（<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1087">issue#1087</a>）。</li>
</ul>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 桶中已经存在元素（处理hash冲突）
    else &#123;
        Node&lt;K,V&gt; e; K k;
        // 判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
        // 判断插入的是否是红黑树节点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 不是红黑树节点则说明为链表结点
        else &#123;
            // 在链表最末插入结点
            for (int binCount = 0; ; ++binCount) &#123;
                // 到达链表的尾部
                if ((e = p.next) == null) &#123;
                    // 在尾部插入新结点
                    p.next = newNode(hash, key, value, null);
                    // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法
                    // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。
                    // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // 跳出循环
                    break;
                &#125;
                // 判断链表中结点的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    // 相等，跳出循环
                    break;
                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                p = e;
            &#125;
        &#125;
        // 表示在桶中找到key值、hash值与插入元素相等的结点
        if (e != null) &#123;
            // 记录e的value
            V oldValue = e.value;
            // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null)
                //用新值替换旧值
                e.value = value;
            // 访问后回调
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        &#125;
    &#125;
    // 结构性修改
    ++modCount;
    // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
&#125;
</code></pre>
<p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p>
<p><strong>对于 put 方法的分析如下：</strong></p>
<ul>
<li>① 如果定位到的数组位置没有元素 就直接插入。</li>
<li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li>
</ul>
<pre><code class="java">public V put(K key, V value)
    if (table == EMPTY_TABLE) &#123;
    inflateTable(threshold);
&#125;
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;

    modCount++;
    addEntry(hash, key, value, i);  // 再插入
    return null;
&#125;
</code></pre>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        // 数组元素相等
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 桶中不止一个节点
        if ((e = first.next) != null) &#123;
            // 在树中get
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 在链表中get
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else &#123;
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    // 计算新的resize上限
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123;
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        // 原索引+oldCap
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<h2 id="HashMap-常用方法测试"><a href="#HashMap-常用方法测试" class="headerlink" title="HashMap 常用方法测试"></a>HashMap 常用方法测试</h2><pre><code class="java">package map;

import java.util.Collection;
import java.util.HashMap;
import java.util.Set;

public class HashMapDemo &#123;

    public static void main(String[] args) &#123;
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        // 键不能重复，值可以重复
        map.put(&quot;san&quot;, &quot;张三&quot;);
        map.put(&quot;si&quot;, &quot;李四&quot;);
        map.put(&quot;wu&quot;, &quot;王五&quot;);
        map.put(&quot;wang&quot;, &quot;老王&quot;);
        map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖
        map.put(&quot;lao&quot;, &quot;老王&quot;);
        System.out.println(&quot;-------直接输出hashmap:-------&quot;);
        System.out.println(map);
        /**
         * 遍历HashMap
         */
        // 1.获取Map中的所有键
        System.out.println(&quot;-------foreach获取Map中所有的键:------&quot;);
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys) &#123;
            System.out.print(key+&quot;  &quot;);
        &#125;
        System.out.println();//换行
        // 2.获取Map中所有值
        System.out.println(&quot;-------foreach获取Map中所有的值:------&quot;);
        Collection&lt;String&gt; values = map.values();
        for (String value : values) &#123;
            System.out.print(value+&quot;  &quot;);
        &#125;
        System.out.println();//换行
        // 3.得到key的值的同时得到key所对应的值
        System.out.println(&quot;-------得到key的值的同时得到key所对应的值:-------&quot;);
        Set&lt;String&gt; keys2 = map.keySet();
        for (String key : keys2) &#123;
            System.out.print(key + &quot;：&quot; + map.get(key)+&quot;   &quot;);

        &#125;
        /**
         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。
         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。
         */
        // 当我调用put(key,value)方法的时候，首先会把key和value封装到
        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取
        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来
        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了
        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();
        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;
            System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue());
        &#125;

        /**
         * HashMap其他常用方法
         */
        System.out.println(&quot;after map.size()：&quot;+map.size());
        System.out.println(&quot;after map.isEmpty()：&quot;+map.isEmpty());
        System.out.println(map.remove(&quot;san&quot;));
        System.out.println(&quot;after map.remove()：&quot;+map);
        System.out.println(&quot;after map.get(si)：&quot;+map.get(&quot;si&quot;));
        System.out.println(&quot;after map.containsKey(si)：&quot;+map.containsKey(&quot;si&quot;));
        System.out.println(&quot;after containsValue(李四)：&quot;+map.containsValue(&quot;李四&quot;));
        System.out.println(map.replace(&quot;si&quot;, &quot;李四2&quot;));
        System.out.println(&quot;after map.replace(si, 李四2):&quot;+map);
    &#125;

&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">阿泽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rongzhiy.github.io/2023/03/17/java/collection/hashmap-source-code/">https://rongzhiy.github.io/2023/03/17/java/collection/hashmap-source-code/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rongzhiy.github.io" target="_blank">Rongzhiyのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9B%86%E5%90%88/">Java集合</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzxjyanj30yq0oewpe.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/17/java/collection/java-collection-precautions-for-use/"><img class="prev-cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzba89fj32yo1uo7ik.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java集合使用注意事项总结</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/17/java/collection/concurrent-hash-map-source-code/"><img class="next-cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjyeqb7nj32yo1o07wh.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ConcurrentHashMap源码&amp;底层数据结构分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/17/java/collection/arraylist-source-code/" title="ArrayList源码&扩容机制分析"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvg5jj8j32vc1m4guo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">ArrayList源码&扩容机制分析</div></div></a></div><div><a href="/2023/03/17/java/collection/concurrent-hash-map-source-code/" title="ConcurrentHashMap源码&底层数据结构分析"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjyeqb7nj32yo1o07wh.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">ConcurrentHashMap源码&底层数据结构分析</div></div></a></div><div><a href="/2023/03/17/java/collection/java-collection-precautions-for-use/" title="Java集合使用注意事项总结"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzba89fj32yo1uo7ik.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java集合使用注意事项总结</div></div></a></div><div><a href="/2023/03/17/java/collection/java-collection-questions-01/" title="Java集合常见面试题总结(上)"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvg5jj8j32vc1m4guo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java集合常见面试题总结(上)</div></div></a></div><div><a href="/2023/03/17/java/collection/java-collection-questions-02/" title="Java集合常见面试题总结(下)"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwalli8j34mo2lrwui.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java集合常见面试题总结(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">阿泽</div><div class="author-info__description">Stay Hungry,Stay Foolish</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rongzhiy"><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:rongzhiy2735@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2735545128&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">HashMap 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">底层数据结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%89%8D"><span class="toc-number">2.1.</span> <span class="toc-text">JDK1.8 之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.2.</span> <span class="toc-text">JDK1.8 之后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">HashMap 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">put 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">get 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">resize 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">HashMap 常用方法测试</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvo1c43j33401r07kx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="李跳跳 安卓跳过广告"/></a><div class="content"><a class="title" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告">李跳跳 安卓跳过广告</a><time datetime="2023-08-27T11:07:56.206Z" title="发表于 2023-08-27 19:07:56">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT使用指南"/></a><div class="content"><a class="title" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南">ChatGPT使用指南</a><time datetime="2023-04-26T12:00:00.000Z" title="发表于 2023-04-26 20:00:00">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="云大千寻 - 基于拍照识别的失物找寻系统"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统">云大千寻 - 基于拍照识别的失物找寻系统</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwpxcmzj34mo2lrkjm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）">基于SpringBoot的校园问答社区系统设计与实现（前后端分离）</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwhqw9nj33401r0npd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 优质开源技术教程"/></a><div class="content"><a class="title" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程">Java 优质开源技术教程</a><time datetime="2023-03-17T09:00:13.505Z" title="发表于 2023-03-17 17:00:13">2023-03-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 阿泽</div><div class="framework-info"><span>框架 </span><a href="">Hexo</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
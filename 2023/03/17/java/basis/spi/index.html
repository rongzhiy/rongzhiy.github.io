<!DOCTYPE html><html lang="zh-CN" data-theme="bright"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java SPI 机制详解 | Rongzhiyのblog</title><meta name="keywords" content="Java基础"><meta name="author" content="阿泽"><meta name="copyright" content="阿泽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文来自 Kingshion 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。  在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。 为了实现在模块装配的时候不用在程序">
<meta property="og:type" content="article">
<meta property="og:title" content="Java SPI 机制详解">
<meta property="og:url" content="https://rongzhiy.github.io/2023/03/17/java/basis/spi/index.html">
<meta property="og:site_name" content="Rongzhiyのblog">
<meta property="og:description" content="本文来自 Kingshion 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。  在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。 为了实现在模块装配的时候不用在程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg">
<meta property="article:published_time" content="2023-03-17T08:59:52.692Z">
<meta property="article:modified_time" content="2023-03-18T04:49:01.941Z">
<meta property="article:author" content="阿泽">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rongzhiy.github.io/2023/03/17/java/basis/spi/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-18 12:49:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Rongzhiyのblog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java SPI 机制详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T08:59:52.692Z" title="发表于 2023-03-17 16:59:52">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-18T04:49:01.941Z" title="更新于 2023-03-18 12:49:01">2023-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java SPI 机制详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>本文来自 <a target="_blank" rel="noopener" href="https://github.com/jjx0708">Kingshion</a> 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a target="_blank" rel="noopener" href="https://javaguide.cn/javaguide/contribution-guideline.html">JavaGuide 贡献指南</a> 。</p>
</blockquote>
<p>在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。</p>
<p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</strong></p>
<h2 id="SPI-介绍"><a href="#SPI-介绍" class="headerlink" title="SPI 介绍"></a>SPI 介绍</h2><h3 id="何谓-SPI"><a href="#何谓-SPI" class="headerlink" title="何谓 SPI?"></a>何谓 SPI?</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg"></p>
<h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p><strong>那 SPI 和 API 有啥区别？</strong></p>
<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png"></p>
<p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>
<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>
<h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><p>SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/image-20220723213306039-165858318917813.png"></p>
<p>这就是依赖 SPI 机制实现的，那我们接下来就实现一个简易版本的日志框架。</p>
<h3 id="Service-Provider-Interface"><a href="#Service-Provider-Interface" class="headerlink" title="Service Provider Interface"></a>Service Provider Interface</h3><p>新建一个 Java 项目 <code>service-provider-interface</code> 目录结构如下：（注意直接新建 Java 项目就好了，不用新建 Maven 项目，Maven 项目会涉及到一些编译配置，如果有私服的话，直接 deploy 会比较方便，但是没有的话，在过程中可能会遇到一些奇怪的问题。）</p>
<pre><code>│  service-provider-interface.iml
│
├─.idea
│  │  .gitignore
│  │  misc.xml
│  │  modules.xml
│  └─ workspace.xml
│
└─src
    └─edu
        └─jiangxuan
            └─up
                └─spi
                        Logger.java
                        LoggerService.java
                        Main.class
</code></pre>
<p>新建 <code>Logger</code> 接口，这个就是 SPI ， 服务提供者接口，后面的服务提供者就要针对这个接口进行实现。</p>
<pre><code class="java">package edu.jiangxuan.up.spi;

public interface Logger &#123;
    void info(String msg);
    void debug(String msg);
&#125;
</code></pre>
<p>接下来就是 <code>LoggerService</code> 类，这个主要是为服务使用者（调用方）提供特定功能的。这个类也是实现 Java SPI 机制的关键所在，如果存在疑惑的话可以先往后面继续看。</p>
<pre><code class="java">package edu.jiangxuan.up.spi;

import java.util.ArrayList;
import java.util.List;
import java.util.ServiceLoader;

public class LoggerService &#123;
    private static final LoggerService SERVICE = new LoggerService();

    private final Logger logger;

    private final List&lt;Logger&gt; loggerList;

    private LoggerService() &#123;
        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);
        List&lt;Logger&gt; list = new ArrayList&lt;&gt;();
        for (Logger log : loader) &#123;
            list.add(log);
        &#125;
        // LoggerList 是所有 ServiceProvider
        loggerList = list;
        if (!list.isEmpty()) &#123;
            // Logger 只取一个
            logger = list.get(0);
        &#125; else &#123;
            logger = null;
        &#125;
    &#125;

    public static LoggerService getService() &#123;
        return SERVICE;
    &#125;

    public void info(String msg) &#123;
        if (logger == null) &#123;
            System.out.println(&quot;info 中没有发现 Logger 服务提供者&quot;);
        &#125; else &#123;
            logger.info(msg);
        &#125;
    &#125;

    public void debug(String msg) &#123;
        if (loggerList.isEmpty()) &#123;
            System.out.println(&quot;debug 中没有发现 Logger 服务提供者&quot;);
        &#125;
        loggerList.forEach(log -&gt; log.debug(msg));
    &#125;
&#125;
</code></pre>
<p>新建 <code>Main</code> 类（服务使用者，调用方），启动程序查看结果。</p>
<pre><code class="java">package org.spi.service;

public class Main &#123;
    public static void main(String[] args) &#123;
        LoggerService service = LoggerService.getService();

        service.info(&quot;Hello SPI&quot;);
        service.debug(&quot;Hello SPI&quot;);
    &#125;
&#125;
</code></pre>
<p>程序结果：</p>
<blockquote>
<p>info 中没有发现 Logger 服务提供者<br>debug 中没有发现 Logger 服务提供者</p>
</blockquote>
<p>此时我们只是空有接口，并没有为 <code>Logger</code> 接口提供任何的实现，所以输出结果中没有按照预期打印相应的结果。</p>
<p>你可以使用命令或者直接使用 IDEA 将整个程序直接打包成 jar 包。</p>
<h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>接下来新建一个项目用来实现 <code>Logger</code> 接口</p>
<p>新建项目 <code>service-provider</code> 目录结构如下：</p>
<pre><code>│  service-provider.iml
│
├─.idea
│  │  .gitignore
│  │  misc.xml
│  │  modules.xml
│  └─ workspace.xml
│
├─lib
│      service-provider-interface.jar
|
└─src
    ├─edu
    │  └─jiangxuan
    │      └─up
    │          └─spi
    │              └─service
    │                      Logback.java
    │
    └─META-INF
        └─services
                edu.jiangxuan.up.spi.Logger
</code></pre>
<p>新建 <code>Logback</code> 类</p>
<pre><code class="java">package edu.jiangxuan.up.spi.service;

import edu.jiangxuan.up.spi.Logger;

public class Logback implements Logger &#123;
    @Override
    public void info(String s) &#123;
        System.out.println(&quot;Logback info 打印日志：&quot; + s);
    &#125;

    @Override
    public void debug(String s) &#123;
        System.out.println(&quot;Logback debug 打印日志：&quot; + s);
    &#125;
&#125;
</code></pre>
<p>将 <code>service-provider-interface</code> 的 jar 导入项目中。</p>
<p>新建 lib 目录，然后将 jar 包拷贝过来，再添加到项目中。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/523d5e25198444d3b112baf68ce49daetplv-k3u1fbpfcp-watermark.png"></p>
<p>再点击 OK 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/f4ba0aa71e9b4d509b9159892a220850tplv-k3u1fbpfcp-watermark.png"></p>
<p>接下来就可以在项目中导入 jar 包里面的一些类和方法了，就像 JDK 工具类导包一样的。</p>
<p>实现 <code>Logger</code> 接口，在 <code>src</code> 目录下新建 <code>META-INF/services</code> 文件夹，然后新建文件 <code>edu.jiangxuan.up.spi.Logger</code> （SPI 的全类名），文件里面的内容是：<code>edu.jiangxuan.up.spi.service.Logback</code> （Logback 的全类名，即 SPI 的实现类的包名 + 类名）。</p>
<p><strong>这是 JDK SPI 机制 ServiceLoader 约定好的标准。</strong></p>
<p>这里先大概解释一下：Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>
<p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p>
<p>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个 jar 包就是服务提供方的实现。通常我们导入 maven 的 pom 依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven 公共仓库中，所以在需要使用的地方只能手动的添加到项目中。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>为了更直观的展示效果，我这里再新建一个专门用来测试的工程项目：<code>java-spi-test</code></p>
<p>然后先导入 <code>Logger</code> 的接口 jar 包，再导入具体的实现类的 jar 包。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/image-20220723215812708-165858469599214.png"></p>
<p>新建 Main 方法测试：</p>
<pre><code class="java">package edu.jiangxuan.up.service;

import edu.jiangxuan.up.spi.LoggerService;

public class TestJavaSPI &#123;
    public static void main(String[] args) &#123;
        LoggerService loggerService = LoggerService.getService();
        loggerService.info(&quot;你好&quot;);
        loggerService.debug(&quot;测试Java SPI 机制&quot;);
    &#125;
&#125;
</code></pre>
<p>运行结果如下：</p>
<blockquote>
<p>Logback info 打印日志：你好<br>Logback debug 打印日志：测试 Java SPI 机制</p>
</blockquote>
<p>说明导入 jar 包中的实现类生效了。</p>
<p>如果我们不导入具体的实现类的 jar 包，那么此时程序运行的结果就会是：</p>
<blockquote>
<p>info 中没有发现 Logger 服务提供者<br>debug 中没有发现 Logger 服务提供者</p>
</blockquote>
<p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和 服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改 <code>service-provider</code> 项目中针对 <code>Logger</code> 接口的具体实现就可以了，只需要换一个 jar 包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J 原理吗？</p>
<p>如果某一天需求变更了，此时需要将日志输出到消息队列，或者做一些别的操作，这个时候完全不需要更改 Logback 的实现，只需要新增一个服务实现（service-provider）可以通过在本项目里面新增实现也可以从外部引入新的服务实现 jar 包。我们可以在服务(LoggerService)中选择一个具体的 服务实现(service-provider) 来完成我们需要的操作。</p>
<p>那么接下来我们具体来说说 Java SPI 工作的重点原理—— <strong>ServiceLoader</strong> 。</p>
<h2 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h2><h3 id="ServiceLoader-具体实现"><a href="#ServiceLoader-具体实现" class="headerlink" title="ServiceLoader 具体实现"></a>ServiceLoader 具体实现</h3><p>想要使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，那么我们接下来看看 <code>ServiceLoader</code> 具体是怎么做的：</p>
<p><code>ServiceLoader</code> 是 JDK 提供的一个工具类， 位于<code>package java.util;</code>包下。</p>
<pre><code>A facility to load implementations of a service.
</code></pre>
<p>这是 JDK 官方给的注释：<strong>一种加载服务实现的工具。</strong></p>
<p>再往下看，我们发现这个类是一个 <code>final</code> 类型的，所以是不可被继承修改，同时它实现了 <code>Iterable</code> 接口。之所以实现了迭代器，是为了方便后续我们能够通过迭代的方式得到对应的服务实现。</p>
<pre><code class="java">public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; xxx...&#125;
</code></pre>
<p>可以看到一个熟悉的常量定义：</p>
<p><code>private static final String PREFIX = &quot;META-INF/services/&quot;;</code></p>
<p>下面是 <code>load</code> 方法：可以发现 <code>load</code> 方法支持两种重载后的入参；</p>
<pre><code class="java">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
&#125;

public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
                                        ClassLoader loader) &#123;
    return new ServiceLoader&lt;&gt;(service, loader);
&#125;

private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;
    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
    reload();
&#125;

public void reload() &#123;
    providers.clear();
    lookupIterator = new LazyIterator(service, loader);
&#125;
</code></pre>
<p>根据代码的调用顺序，在 <code>reload()</code> 方法中是通过一个内部类 <code>LazyIterator</code> 实现的。先继续往下面看。</p>
<p><code>ServiceLoader</code> 实现了 <code>Iterable</code> 接口的方法后，具有了迭代的能力，在这个 <code>iterator</code> 方法被调用时，首先会在 <code>ServiceLoader</code> 的 <code>Provider</code> 缓存中进行查找，如果缓存中没有命中那么则在 <code>LazyIterator</code> 中进行查找。</p>
<pre><code class="java">
public Iterator&lt;S&gt; iterator() &#123;
    return new Iterator&lt;S&gt;() &#123;

        Iterator&lt;Map.Entry&lt;String, S&gt;&gt; knownProviders
                = providers.entrySet().iterator();

        public boolean hasNext() &#123;
            if (knownProviders.hasNext())
                return true;
            return lookupIterator.hasNext(); // 调用 LazyIterator
        &#125;

        public S next() &#123;
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next(); // 调用 LazyIterator
        &#125;

        public void remove() &#123;
            throw new UnsupportedOperationException();
        &#125;

    &#125;;
&#125;
</code></pre>
<p>在调用 <code>LazyIterator</code> 时，具体实现如下：</p>
<pre><code class="java">
public boolean hasNext() &#123;
    if (acc == null) &#123;
        return hasNextService();
    &#125; else &#123;
        PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123;
            public Boolean run() &#123;
                return hasNextService();
            &#125;
        &#125;;
        return AccessController.doPrivileged(action, acc);
    &#125;
&#125;

private boolean hasNextService() &#123;
    if (nextName != null) &#123;
        return true;
    &#125;
    if (configs == null) &#123;
        try &#123;
            //通过PREFIX（META-INF/services/）和类名 获取对应的配置文件，得到具体的实现类
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
                configs = loader.getResources(fullName);
        &#125; catch (IOException x) &#123;
            fail(service, &quot;Error locating configuration files&quot;, x);
        &#125;
    &#125;
    while ((pending == null) || !pending.hasNext()) &#123;
        if (!configs.hasMoreElements()) &#123;
            return false;
        &#125;
        pending = parse(service, configs.nextElement());
    &#125;
    nextName = pending.next();
    return true;
&#125;


public S next() &#123;
    if (acc == null) &#123;
        return nextService();
    &#125; else &#123;
        PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123;
            public S run() &#123;
                return nextService();
            &#125;
        &#125;;
        return AccessController.doPrivileged(action, acc);
    &#125;
&#125;

private S nextService() &#123;
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&lt;?&gt; c = null;
    try &#123;
        c = Class.forName(cn, false, loader);
    &#125; catch (ClassNotFoundException x) &#123;
        fail(service,
                &quot;Provider &quot; + cn + &quot; not found&quot;);
    &#125;
    if (!service.isAssignableFrom(c)) &#123;
        fail(service,
                &quot;Provider &quot; + cn + &quot; not a subtype&quot;);
    &#125;
    try &#123;
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    &#125; catch (Throwable x) &#123;
        fail(service,
                &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
                x);
    &#125;
    throw new Error();          // This cannot happen
&#125;
</code></pre>
<p>可能很多人看这个会觉得有点复杂，没关系，我这边实现了一个简单的 <code>ServiceLoader</code> 的小模型，流程和原理都是保持一致的，可以先从自己实现一个简易版本的开始学：</p>
<h3 id="自己实现一个-ServiceLoader"><a href="#自己实现一个-ServiceLoader" class="headerlink" title="自己实现一个 ServiceLoader"></a>自己实现一个 ServiceLoader</h3><p>我先把代码贴出来：</p>
<pre><code class="java">package edu.jiangxuan.up.service;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;

public class MyServiceLoader&lt;S&gt; &#123;

    // 对应的接口 Class 模板
    private final Class&lt;S&gt; service;

    // 对应实现类的 可以有多个，用 List 进行封装
    private final List&lt;S&gt; providers = new ArrayList&lt;&gt;();

    // 类加载器
    private final ClassLoader classLoader;

    // 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。
    public static &lt;S&gt; MyServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;
        return new MyServiceLoader&lt;&gt;(service);
    &#125;

    // 构造方法私有化
    private MyServiceLoader(Class&lt;S&gt; service) &#123;
        this.service = service;
        this.classLoader = Thread.currentThread().getContextClassLoader();
        doLoad();
    &#125;

    // 关键方法，加载具体实现类的逻辑
    private void doLoad() &#123;
        try &#123;
            // 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名
            Enumeration&lt;URL&gt; urls = classLoader.getResources(&quot;META-INF/services/&quot; + service.getName());
            // 挨个遍历取到的文件
            while (urls.hasMoreElements()) &#123;
                // 取出当前的文件
                URL url = urls.nextElement();
                System.out.println(&quot;File = &quot; + url.getPath());
                // 建立链接
                URLConnection urlConnection = url.openConnection();
                urlConnection.setUseCaches(false);
                // 获取文件输入流
                InputStream inputStream = urlConnection.getInputStream();
                // 从文件输入流获取缓存
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
                // 从文件内容里面得到实现类的全类名
                String className = bufferedReader.readLine();

                while (className != null) &#123;
                    // 通过反射拿到实现类的实例
                    Class&lt;?&gt; clazz = Class.forName(className, false, classLoader);
                    // 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例
                    if (service.isAssignableFrom(clazz)) &#123;
                        Constructor&lt;? extends S&gt; constructor = (Constructor&lt;? extends S&gt;) clazz.getConstructor();
                        S instance = constructor.newInstance();
                        // 把当前构造的实例对象添加到 Provider的列表里面
                        providers.add(instance);
                    &#125;
                    // 继续读取下一行的实现类，可以有多个实现类，只需要换行就可以了。
                    className = bufferedReader.readLine();
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;读取文件异常。。。&quot;);
        &#125;
    &#125;

    // 返回spi接口对应的具体实现类列表
    public List&lt;S&gt; getProviders() &#123;
        return providers;
    &#125;
&#125;
</code></pre>
<p>关键信息基本已经通过代码注释描述出来了，</p>
<p>主要的流程就是：</p>
<ol>
<li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li>
<li>读取这个文件的名称找到对应的 spi 接口，</li>
<li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li>
<li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li>
<li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不难发现，SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 <code>META-INF/services/</code> 文件下声明。</strong></p>
<p>另外，SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的反射。还有 Dubbo 框架提供同样的 SPI 扩展机制，只不过 Dubbo 和 spring 框架中的 SPI 机制具体实现方式跟咱们今天学得这个有些细微的区别，不过整体的原理都是一致的，相信大家通过对 JDK 中 SPI 机制的学习，能够一通百通，加深对其他高深框的理解。</p>
<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>
<ol>
<li>遍历加载所有的实现类，这样效率还是相对较低的；</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">阿泽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rongzhiy.github.io/2023/03/17/java/basis/spi/">https://rongzhiy.github.io/2023/03/17/java/basis/spi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rongzhiy.github.io" target="_blank">Rongzhiyのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/17/java/basis/syntactic-sugar/"><img class="prev-cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjw34a78j33401r049h.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 语法糖详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/17/java/basis/serialization/"><img class="next-cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjz5coc5j31z40w04qp.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 序列化详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/17/java/basis/bigdecimal/" title="BigDecimal 详解"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvx16qej33jw2004qp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">BigDecimal 详解</div></div></a></div><div><a href="/2023/03/17/java/basis/java-basic-questions-02/" title="Java基础常见面试题总结(中)"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvg5jj8j32vc1m4guo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java基础常见面试题总结(中)</div></div></a></div><div><a href="/2023/03/17/java/basis/java-basic-questions-01/" title="Java基础常见面试题总结(上)"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzba89fj32yo1uo7ik.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java基础常见面试题总结(上)</div></div></a></div><div><a href="/2023/03/17/java/basis/java-basic-questions-03/" title="Java基础常见面试题总结(下)"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjzxjyanj30yq0oewpe.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java基础常见面试题总结(下)</div></div></a></div><div><a href="/2023/03/17/java/basis/proxy/" title="Java 代理模式详解"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjvx16qej33jw2004qp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java 代理模式详解</div></div></a></div><div><a href="/2023/03/17/java/basis/reflection/" title="Java 反射机制详解"><img class="cover" src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwalli8j34mo2lrwui.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">Java 反射机制详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">阿泽</div><div class="author-info__description">Stay Hungry,Stay Foolish</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rongzhiy"><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:rongzhiy2735@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2735545128&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">SPI 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E8%B0%93-SPI"><span class="toc-number">1.1.</span> <span class="toc-text">何谓 SPI?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI-%E5%92%8C-API-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">SPI 和 API 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%BC%94%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">实战演示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Provider-Interface"><span class="toc-number">2.1.</span> <span class="toc-text">Service Provider Interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Provider"><span class="toc-number">2.2.</span> <span class="toc-text">Service Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">2.3.</span> <span class="toc-text">效果展示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceLoader"><span class="toc-number">3.</span> <span class="toc-text">ServiceLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServiceLoader-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">ServiceLoader 具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ServiceLoader"><span class="toc-number">3.2.</span> <span class="toc-text">自己实现一个 ServiceLoader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwpxcmzj34mo2lrkjm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="李跳跳 安卓跳过广告"/></a><div class="content"><a class="title" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告">李跳跳 安卓跳过广告</a><time datetime="2023-08-27T11:07:56.206Z" title="发表于 2023-08-27 19:07:56">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwhqw9nj33401r0npd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT使用指南"/></a><div class="content"><a class="title" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南">ChatGPT使用指南</a><time datetime="2023-04-26T12:00:00.000Z" title="发表于 2023-04-26 20:00:00">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjyp7zrtj32yo1o0kjm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="云大千寻 - 基于拍照识别的失物找寻系统"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统">云大千寻 - 基于拍照识别的失物找寻系统</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）">基于SpringBoot的校园问答社区系统设计与实现（前后端分离）</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程"><img src="https://tva1.sinaimg.cn/large/008ApSknly1hhbjwhqw9nj33401r0npd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 优质开源技术教程"/></a><div class="content"><a class="title" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程">Java 优质开源技术教程</a><time datetime="2023-03-17T09:00:13.505Z" title="发表于 2023-03-17 17:00:13">2023-03-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 阿泽</div><div class="framework-info"><span>框架 </span><a href="">Hexo</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
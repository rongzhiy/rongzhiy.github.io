<!DOCTYPE html><html lang="zh-CN" data-theme="bright"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Rongzhiyのblog | Rongzhiyのblog</title><meta name="keywords" content="rongzhiy"><meta name="author" content="阿泽"><meta name="copyright" content="阿泽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="same-origin">
<meta name="referrer" content="no-referrer" /><meta name="description" content="Java8 新特性实战 本文来自cowbi的投稿~  Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。 为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 in">
<meta property="og:type" content="article">
<meta property="og:title" content="Rongzhiyのblog">
<meta property="og:url" content="https://rongzhiy.github.io/2023/03/17/java/new-features/java8-common-new-features/index.html">
<meta property="og:site_name" content="Rongzhiyのblog">
<meta property="og:description" content="Java8 新特性实战 本文来自cowbi的投稿~  Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。 为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/08/27/cvFmZnB4jEaNqxg.jpg">
<meta property="article:published_time" content="2023-03-17T08:59:53.057Z">
<meta property="article:modified_time" content="2023-03-16T07:55:48.000Z">
<meta property="article:author" content="阿泽">
<meta property="article:tag" content="rongzhiy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/08/27/cvFmZnB4jEaNqxg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rongzhiy.github.io/2023/03/17/java/new-features/java8-common-new-features/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-16 15:55:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/images/loading.png" data-original="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Rongzhiyのblog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T08:59:53.057Z" title="发表于 2023-03-17 16:59:53">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-16T07:55:48.000Z" title="更新于 2023-03-16 15:55:48">2023-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Java8-新特性实战"><a href="#Java8-新特性实战" class="headerlink" title="Java8 新特性实战"></a>Java8 新特性实战</h1><blockquote>
<p>本文来自<a target="_blank" rel="noopener" href="https://github.com/cowbi">cowbi</a>的投稿~</p>
</blockquote>
<p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。</p>
<p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p>
<p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>
<p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p>
<ol>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li>
</ol>
<p>我们来看一个实际的例子。</p>
<pre><code class="java">public interface InterfaceNew &#123;
    static void sm() &#123;
        System.out.println(&quot;interface提供的方式实现&quot;);
    &#125;
    static void sm2() &#123;
        System.out.println(&quot;interface提供的方式实现&quot;);
    &#125;

    default void def() &#123;
        System.out.println(&quot;interface default方法&quot;);
    &#125;
    default void def2() &#123;
        System.out.println(&quot;interface default2方法&quot;);
    &#125;
    //须要实现类重写
    void f();
&#125;

public interface InterfaceNew1 &#123;
    default void def() &#123;
        System.out.println(&quot;InterfaceNew1 default方法&quot;);
    &#125;
&#125;
</code></pre>
<p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p>
<pre><code class="java">public class InterfaceNewImpl implements InterfaceNew , InterfaceNew1&#123;
    public static void main(String[] args) &#123;
        InterfaceNewImpl interfaceNew = new InterfaceNewImpl();
        interfaceNew.def();
    &#125;

    @Override
    public void def() &#123;
        InterfaceNew1.super.def();
    &#125;

    @Override
    public void f() &#123;
    &#125;
&#125;
</code></pre>
<p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p>
<p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p>
<p>其实它们还是有区别的</p>
<ol>
<li><p>interface 和 class 的区别，好像是废话，主要有：</p>
<ul>
<li>接口多实现，类单继承</li>
<li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
</ul>
</li>
<li><p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p>
</li>
</ol>
<p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>
<p><strong>记住接口永远和类不一样。</strong></p>
<h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p>
<p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p>
<p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有</p>
<p><code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p>
<blockquote>
<p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p>
</blockquote>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><pre><code class="java">(parameters) -&gt; expression 或
(parameters) -&gt;&#123; statements; &#125;
</code></pre>
<h3 id="Lambda-实战"><a href="#Lambda-实战" class="headerlink" title="Lambda 实战"></a>Lambda 实战</h3><p>我们用常用的实例来感受 Lambda 带来的便利</p>
<h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p>
<p><strong>1.<code>Runnable</code> 接口</strong></p>
<pre><code class="java">new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;The runable now is using!&quot;);
            &#125;
&#125;).start();
//用lambda
new Thread(() -&gt; System.out.println(&quot;It&#39;s a lambda function!&quot;)).start();
</code></pre>
<p><strong>2.<code>Comparator</code> 接口</strong></p>
<pre><code class="java">List&lt;Integer&gt; strings = Arrays.asList(1, 2, 3);

Collections.sort(strings, new Comparator&lt;Integer&gt;() &#123;
@Override
public int compare(Integer o1, Integer o2) &#123;
    return o1 - o2;&#125;
&#125;);

//Lambda
Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);
//分解开
Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;
Collections.sort(strings, comparator);
</code></pre>
<p><strong>3.<code>Listener</code> 接口</strong></p>
<pre><code class="java">JButton button = new JButton();
button.addItemListener(new ItemListener() &#123;
@Override
public void itemStateChanged(ItemEvent e) &#123;
   e.getItem();
&#125;
&#125;);
//lambda
button.addItemListener(e -&gt; e.getItem());
</code></pre>
<p><strong>4.自定义接口</strong></p>
<p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p>
<pre><code class="java">@FunctionalInterface
public interface Comparator&lt;T&gt;&#123;&#125;

@FunctionalInterface
public interface Runnable&#123;&#125;
</code></pre>
<p>我们自定义一个函数式接口</p>
<pre><code class="java">@FunctionalInterface
public interface LambdaInterface &#123;
 void f();
&#125;
//使用
public class LambdaClass &#123;
    public static void forEg() &#123;
        lambdaInterfaceDemo(()-&gt; System.out.println(&quot;自定义函数式接口&quot;));
    &#125;
    //函数式接口参数
    static void lambdaInterfaceDemo(LambdaInterface i)&#123;
        i.f();
    &#125;
&#125;
</code></pre>
<h4 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h4><pre><code class="java">void lamndaFor() &#123;
        List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
        //传统foreach
        for (String s : strings) &#123;
            System.out.println(s);
        &#125;
        //Lambda foreach
        strings.forEach((s) -&gt; System.out.println(s));
        //or
        strings.forEach(System.out::println);
                 //map
        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
        map.forEach((k,v)-&gt;System.out.println(v));
&#125;
</code></pre>
<h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p>
<pre><code class="java">public class LambdaClassSuper &#123;
    LambdaInterface sf()&#123;
        return null;
    &#125;
&#125;

public class LambdaClass extends LambdaClassSuper &#123;
    public static LambdaInterface staticF() &#123;
        return null;
    &#125;

    public LambdaInterface f() &#123;
        return null;
    &#125;

    void show() &#123;
        //1.调用静态函数，返回类型必须是functional-interface
        LambdaInterface t = LambdaClass::staticF;

        //2.实例方法调用
        LambdaClass lambdaClass = new LambdaClass();
        LambdaInterface lambdaInterface = lambdaClass::f;

        //3.超类上的方法调用
        LambdaInterface superf = super::sf;

        //4. 构造方法调用
        LambdaInterface tt = LambdaClassSuper::new;
    &#125;
&#125;
</code></pre>
<h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><pre><code class="java">int i = 0;
Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);
//i =3;
</code></pre>
<p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol>
<li>stream 串行流</li>
<li>parallelStream 并行流，可多线程执行</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p>
<pre><code class="java">/**
* 返回一个串行流
*/
default Stream&lt;E&gt; stream()

/**
* 返回一个并行流
*/
default Stream&lt;E&gt; parallelStream()

/**
* 返回T的流
*/
public static&lt;T&gt; Stream&lt;T&gt; of(T t)

/**
* 返回其元素是指定值的顺序流。
*/
public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;
    return Arrays.stream(values);
&#125;


/**
* 过滤，返回由与给定predicate匹配的该流的元素组成的流
*/
Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);

/**
* 此流的所有元素是否与提供的predicate匹配。
*/
boolean allMatch(Predicate&lt;? super T&gt; predicate)

/**
* 此流任意元素是否有与提供的predicate匹配。
*/
boolean anyMatch(Predicate&lt;? super T&gt; predicate);

/**
* 返回一个 Stream的构建器。
*/
public static&lt;T&gt; Builder&lt;T&gt; builder();

/**
* 使用 Collector对此流的元素进行归纳
*/
&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);

/**
 * 返回此流中的元素数。
*/
long count();

/**
* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。
*/
Stream&lt;T&gt; distinct();

/**
 * 遍历
*/
void forEach(Consumer&lt;? super T&gt; action);

/**
* 用于获取指定数量的流，截短长度不能超过 maxSize 。
*/
Stream&lt;T&gt; limit(long maxSize);

/**
* 用于映射每个元素到对应的结果
*/
&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);

/**
* 根据提供的 Comparator进行排序。
*/
Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);

/**
* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。
*/
Stream&lt;T&gt; skip(long n);

/**
* 返回一个包含此流的元素的数组。
*/
Object[] toArray();

/**
* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。
*/
&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);

/**
* 合并流
*/
public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)
</code></pre>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p>
<pre><code class="java">@Test
public void test() &#123;
  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;def&quot;, &quot;gkh&quot;, &quot;abc&quot;);
    //返回符合条件的stream
    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; &quot;abc&quot;.equals(s));
    //计算流符合条件的流的数量
    long count = stringStream.count();

    //forEach遍历-&gt;打印元素
    strings.stream().forEach(System.out::println);

    //limit 获取到1个元素的stream
    Stream&lt;String&gt; limit = strings.stream().limit(1);
    //toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环
    String[] array = limit.toArray(String[]::new);

    //map 对每个元素进行操作返回新流
    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + &quot;22&quot;);

    //sorted 排序并打印
    strings.stream().sorted().forEach(System.out::println);

    //Collectors collect 把abc放入容器中
    List&lt;String&gt; collect = strings.stream().filter(string -&gt; &quot;abc&quot;.equals(string)).collect(Collectors.toList());
    //把list转为string，各元素用，号隔开
    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;,&quot;));

    //对数组的统计，比如用
    List&lt;Integer&gt; number = Arrays.asList(1, 2, 5, 4);

    IntSummaryStatistics statistics = number.stream().mapToInt((x) -&gt; x).summaryStatistics();
    System.out.println(&quot;列表中最大的数 : &quot;+statistics.getMax());
    System.out.println(&quot;列表中最小的数 : &quot;+statistics.getMin());
    System.out.println(&quot;平均数 : &quot;+statistics.getAverage());
    System.out.println(&quot;所有数之和 : &quot;+statistics.getSum());

    //concat 合并流
    List&lt;String&gt; strings2 = Arrays.asList(&quot;xyz&quot;, &quot;jqx&quot;);
    Stream.concat(strings2.stream(),strings.stream()).count();

    //注意 一个Stream只能操作一次，不能断开，否则会报错。
    Stream stream = strings.stream();
    //第一次使用
    stream.limit(2);
    //第二次使用
    stream.forEach(System.out::println);
    //报错 java.lang.IllegalStateException: stream has already been operated upon or closed

    //但是可以这样, 连续使用
    stream.limit(2).forEach(System.out::println);
&#125;
</code></pre>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p>
<p>我们下面分解一下 <code>filter</code> 方法。</p>
<pre><code class="java">@Test
public void laziness()&#123;
  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;def&quot;, &quot;gkh&quot;, &quot;abc&quot;);
  Stream&lt;Integer&gt; stream = strings.stream().filter(new Predicate() &#123;
      @Override
      public boolean test(Object o) &#123;
        System.out.println(&quot;Predicate.test 执行&quot;);
        return true;
        &#125;
      &#125;);

   System.out.println(&quot;count 执行&quot;);
   stream.count();
&#125;
/*-------执行结果--------*/
count 执行
Predicate.test 执行
Predicate.test 执行
Predicate.test 执行
Predicate.test 执行
</code></pre>
<p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p>
<p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p>
<pre><code class="java">@Test
public void parallelStreamTest()&#123;
   List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 5, 4);
   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+num));
&#125;
//执行结果
main&gt;&gt;5
ForkJoinPool.commonPool-worker-2&gt;&gt;4
ForkJoinPool.commonPool-worker-11&gt;&gt;1
ForkJoinPool.commonPool-worker-9&gt;&gt;2
</code></pre>
<p>从结果中我们看到，for-each 用到的是多线程。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从源码和实例中我们可以总结出一些 stream 的特点</p>
<ol>
<li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li>
<li>方法参数都是函数式接口类型</li>
<li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li>
<li>Stream 不保存数据，不改变数据源</li>
</ol>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>在<a target="_blank" rel="noopener" href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p>
<blockquote>
<p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>
<p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p>
<p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>
<p>2） 数据库的查询结果可能为 null。</p>
<p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>
<p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p>
<p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p>
<p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p>
<p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p>
</blockquote>
<p>他建议使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p>
<p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p>
<pre><code class="java">class Zoo &#123;
   private Dog dog;
&#125;

class Dog &#123;
   private int age;
&#125;
</code></pre>
<p>传统解决 NPE 的办法如下：</p>
<pre><code class="java">Zoo zoo = getZoo();
if(zoo != null)&#123;
   Dog dog = zoo.getDog();
   if(dog != null)&#123;
      int age = dog.getAge();
      System.out.println(age);
   &#125;
&#125;
</code></pre>
<p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p>
<p><code>Optional</code> 是这样的实现的：</p>
<pre><code class="java">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;
    System.out.println(age)
);
</code></pre>
<p>是不是简洁了很多呢？</p>
<h3 id="如何创建一个-Optional"><a href="#如何创建一个-Optional" class="headerlink" title="如何创建一个 Optional"></a>如何创建一个 Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p>
<pre><code class="java">/**
* Common instance for &#123;@code empty()&#125;. 全局EMPTY对象
*/
private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();

/**
* Optional维护的值
*/
private final T value;

/**
* 如果value是null就返回EMPTY，否则就返回of(T)
*/
public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;
   return value == null ? empty() : of(value);
&#125;
/**
* 返回 EMPTY 对象
*/
public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;
   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;
   return t;
&#125;
/**
* 返回Optional对象
*/
public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;
    return new Optional&lt;&gt;(value);
&#125;
/**
* 私有构造方法，给value赋值
*/
private Optional(T value) &#123;
  this.value = Objects.requireNonNull(value);
&#125;
/**
* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题
*/
public static &lt;T&gt; T requireNonNull(T obj) &#123;
  if (obj == null)
         throw new NullPointerException();
  return obj;
&#125;
</code></pre>
<p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p>
<h3 id="map-相关方法。"><a href="#map-相关方法。" class="headerlink" title="map()相关方法。"></a><code>map()</code>相关方法。</h3><pre><code class="java">/**
* 如果value为null，返回EMPTY，否则返回Optional封装的参数值
*/
public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;
        Objects.requireNonNull(mapper);
        if (!isPresent())
            return empty();
        else &#123;
            return Optional.ofNullable(mapper.apply(value));
        &#125;
&#125;
/**
* 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException
*/
public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123;
        Objects.requireNonNull(mapper);
        if (!isPresent())
            return empty();
        else &#123;
            return Objects.requireNonNull(mapper.apply(value));
        &#125;
&#125;
</code></pre>
<p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p>
<p><strong>1.参数不一样，<code>map</code> 的参数上面看到过，<code>flatMap</code> 的参数是这样</strong></p>
<pre><code class="java">class ZooFlat &#123;
        private DogFlat dog = new DogFlat();

        public DogFlat getDog() &#123;
            return dog;
        &#125;
    &#125;

class DogFlat &#123;
        private int age = 1;
        public Optional&lt;Integer&gt; getAge() &#123;
            return Optional.ofNullable(age);
        &#125;
&#125;

ZooFlat zooFlat = new ZooFlat();
Optional.ofNullable(zooFlat).map(o -&gt; o.getDog()).flatMap(d -&gt; d.getAge()).ifPresent(age -&gt;
    System.out.println(age)
);
</code></pre>
<p><strong>2.<code>flatMap()</code> 参数返回值如果是 null 会抛 <code>NullPointerException</code>，而 <code>map()</code> 返回<code>EMPTY</code>。</strong></p>
<h3 id="判断-value-是否为-null"><a href="#判断-value-是否为-null" class="headerlink" title="判断 value 是否为 null"></a>判断 value 是否为 null</h3><pre><code class="java">/**
* value是否为null
*/
public boolean isPresent() &#123;
    return value != null;
&#125;
/**
* 如果value不为null执行consumer.accept
*/
public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;
   if (value != null)
    consumer.accept(value);
&#125;
</code></pre>
<h3 id="获取-value"><a href="#获取-value" class="headerlink" title="获取 value"></a>获取 value</h3><pre><code class="java">/**
* Return the value if present, otherwise invoke &#123;@code other&#125; and return
* the result of that invocation.
* 如果value != null 返回value，否则返回other的执行结果
*/
public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;
    return value != null ? value : other.get();
&#125;

/**
* 如果value != null 返回value，否则返回T
*/
public T orElse(T other) &#123;
    return value != null ? value : other;
&#125;

/**
* 如果value != null 返回value，否则抛出参数返回的异常
*/
public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;
        if (value != null) &#123;
            return value;
        &#125; else &#123;
            throw exceptionSupplier.get();
        &#125;
&#125;
/**
* value为null抛出NoSuchElementException，不为空返回value。
*/
public T get() &#123;
  if (value == null) &#123;
      throw new NoSuchElementException(&quot;No value present&quot;);
  &#125;
  return value;
&#125;
</code></pre>
<h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><pre><code class="java">/**
* 1. 如果是empty返回empty
* 2. predicate.test(value)==true 返回this，否则返回empty
*/
public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;
        Objects.requireNonNull(predicate);
        if (!isPresent())
            return this;
        else
            return predicate.test(value) ? this : empty();
&#125;
</code></pre>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of() </code>、 <code>get()</code> 、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p>
<pre><code class="java">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).filter(v-&gt;v==1).orElse(3);
</code></pre>
<h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p>
<ol>
<li>非线程安全</li>
<li>时区处理麻烦</li>
<li>各种格式化、和时间计算繁琐</li>
<li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li>
</ol>
<p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p>
<h3 id="java-time-主要类"><a href="#java-time-主要类" class="headerlink" title="java.time 主要类"></a>java.time 主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而  <code>java.time</code> 把它们进行了分离</p>
<pre><code class="java">LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS
LocalDate.class //日期 format: yyyy-MM-dd
LocalTime.class //时间 format: HH:mm:ss
</code></pre>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><strong>Java 8 之前:</strong></p>
<pre><code class="java">public void oldFormat()&#123;
    Date now = new Date();
    //format yyyy-MM-dd
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    String date  = sdf.format(now);
    System.out.println(String.format(&quot;date format : %s&quot;, date));

    //format HH:mm:ss
    SimpleDateFormat sdft = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
    String time = sdft.format(now);
    System.out.println(String.format(&quot;time format : %s&quot;, time));

    //format yyyy-MM-dd HH:mm:ss
    SimpleDateFormat sdfdt = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String datetime = sdfdt.format(now);
    System.out.println(String.format(&quot;dateTime format : %s&quot;, datetime));
&#125;
</code></pre>
<p><strong>Java 8 之后:</strong></p>
<pre><code class="java">public void newFormat()&#123;
    //format yyyy-MM-dd
    LocalDate date = LocalDate.now();
    System.out.println(String.format(&quot;date format : %s&quot;, date));

    //format HH:mm:ss
    LocalTime time = LocalTime.now().withNano(0);
    System.out.println(String.format(&quot;time format : %s&quot;, time));

    //format yyyy-MM-dd HH:mm:ss
    LocalDateTime dateTime = LocalDateTime.now();
    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String dateTimeStr = dateTime.format(dateTimeFormatter);
    System.out.println(String.format(&quot;dateTime format : %s&quot;, dateTimeStr));
&#125;
</code></pre>
<h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p><strong>Java 8 之前:</strong></p>
<pre><code class="java">//已弃用
Date date = new Date(&quot;2021-01-26&quot;);
//替换为
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
Date date1 = sdf.parse(&quot;2021-01-26&quot;);
</code></pre>
<p><strong>Java 8 之后:</strong></p>
<pre><code class="java">LocalDate date = LocalDate.of(2021, 1, 26);
LocalDate.parse(&quot;2021-01-26&quot;);

LocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22);
LocalDateTime.parse(&quot;2021-01-26 12:12:22&quot;);

LocalTime time = LocalTime.of(12, 12, 22);
LocalTime.parse(&quot;12:12:22&quot;);
</code></pre>
<p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的  <code>of</code> 或 <code>parse</code> 方法。</p>
<h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1&#x2F;2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p>
<p><strong>Java 8 之前:</strong></p>
<pre><code class="java">public void afterDay()&#123;
     //一周后的日期
     SimpleDateFormat formatDate = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
     Calendar ca = Calendar.getInstance();
     ca.add(Calendar.DATE, 7);
     Date d = ca.getTime();
     String after = formatDate.format(d);
     System.out.println(&quot;一周后日期：&quot; + after);

   //算两个日期间隔多少天，计算间隔多少年，多少月方法类似
     String dates1 = &quot;2021-12-23&quot;;
   String dates2 = &quot;2021-02-26&quot;;
     SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
     Date date1 = format.parse(dates1);
     Date date2 = format.parse(dates2);
     int day = (int) ((date1.getTime() - date2.getTime()) / (1000 * 3600 * 24));
     System.out.println(dates1 + &quot;和&quot; + dates2 + &quot;相差&quot; + day + &quot;天&quot;);
     //结果：2021-02-26和2021-12-23相差300天
&#125;
</code></pre>
<p><strong>Java 8 之后:</strong></p>
<pre><code class="java">public void pushWeek()&#123;
     //一周后的日期
     LocalDate localDate = LocalDate.now();
     //方法1
     LocalDate after = localDate.plus(1, ChronoUnit.WEEKS);
     //方法2
     LocalDate after2 = localDate.plusWeeks(1);
     System.out.println(&quot;一周后日期：&quot; + after);

     //算两个日期间隔多少天，计算间隔多少年，多少月
     LocalDate date1 = LocalDate.parse(&quot;2021-02-26&quot;);
     LocalDate date2 = LocalDate.parse(&quot;2021-12-23&quot;);
     Period period = Period.between(date1, date2);
     System.out.println(&quot;date1 到 date2 相隔：&quot;
                + period.getYears() + &quot;年&quot;
                + period.getMonths() + &quot;月&quot;
                + period.getDays() + &quot;天&quot;);
         //打印结果是 “date1 到 date2 相隔：0年9月27天”
     //这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数
     //如果要获取纯粹的总天数应该用下面的方法
     long day = date2.toEpochDay() - date1.toEpochDay();
     System.out.println(date1 + &quot;和&quot; + date2 + &quot;相差&quot; + day + &quot;天&quot;);
     //打印结果：2021-02-26和2021-12-23相差300天
&#125;
</code></pre>
<h3 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h3><p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>
<p><strong>Java 8 之前:</strong></p>
<pre><code class="java">public void getDay() &#123;

        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        //获取当前月第一天：
        Calendar c = Calendar.getInstance();
        c.set(Calendar.DAY_OF_MONTH, 1);
        String first = format.format(c.getTime());
        System.out.println(&quot;first day:&quot; + first);

        //获取当前月最后一天
        Calendar ca = Calendar.getInstance();
        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));
        String last = format.format(ca.getTime());
        System.out.println(&quot;last day:&quot; + last);

        //当年最后一天
        Calendar currCal = Calendar.getInstance();
        Calendar calendar = Calendar.getInstance();
        calendar.clear();
        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));
        calendar.roll(Calendar.DAY_OF_YEAR, -1);
        Date time = calendar.getTime();
        System.out.println(&quot;last day:&quot; + format.format(time));
&#125;
</code></pre>
<p><strong>Java 8 之后:</strong></p>
<pre><code class="java">public void getDayNew() &#123;
    LocalDate today = LocalDate.now();
    //获取当前月第一天：
    LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth());
    // 取本月最后一天
    LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth());
    //取下一天：
    LocalDate nextDay = lastDayOfThisMonth.plusDays(1);
    //当年最后一天
    LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear());
    //2021年最后一个周日，如果用Calendar是不得烦死。
    LocalDate lastMondayOf2021 = LocalDate.parse(&quot;2021-12-31&quot;).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));
&#125;
</code></pre>
<p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p>
<h3 id="JDBC-和-java8"><a href="#JDBC-和-java8" class="headerlink" title="JDBC 和 java8"></a>JDBC 和 java8</h3><p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p>
<ol>
<li><code>Date</code> —&gt; <code>LocalDate</code></li>
<li><code>Time</code> —&gt; <code>LocalTime</code></li>
<li><code>Timestamp</code> —&gt; <code>LocalDateTime</code></li>
</ol>
<p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><blockquote>
<p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p>
</blockquote>
<p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p>
<pre><code class="java">//北京时间：Wed Jan 27 14:05:29 CST 2021
Date date = new Date();

SimpleDateFormat bjSdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
//北京时区
bjSdf.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));
System.out.println(&quot;毫秒数:&quot; + date.getTime() + &quot;, 北京时间:&quot; + bjSdf.format(date));

//东京时区
SimpleDateFormat tokyoSdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
tokyoSdf.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;));  // 设置东京时区
System.out.println(&quot;毫秒数:&quot; + date.getTime() + &quot;, 东京时间:&quot; + tokyoSdf.format(date));

//如果直接print会自动转成当前时区的时间
System.out.println(date);
//Wed Jan 27 14:05:29 CST 2021
</code></pre>
<p>在新特性中引入了  <code>java.time.ZonedDateTime </code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p>
<pre><code class="java">//当前时区时间
ZonedDateTime zonedDateTime = ZonedDateTime.now();
System.out.println(&quot;当前时区时间: &quot; + zonedDateTime);

//东京时间
ZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(&quot;JST&quot;));
ZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId);
System.out.println(&quot;东京时间: &quot; + tokyoTime);

// ZonedDateTime 转 LocalDateTime
LocalDateTime localDateTime = tokyoTime.toLocalDateTime();
System.out.println(&quot;东京时间转当地时间: &quot; + localDateTime);

//LocalDateTime 转 ZonedDateTime
ZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault());
System.out.println(&quot;本地时区时间: &quot; + localZoned);

//打印结果
当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai]
东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo]
东京时间转当地时间: 2021-01-27T15:43:58.735
当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai]
</code></pre>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们梳理总结的 java 8 新特性有</p>
<ul>
<li>Interface &amp; functional Interface</li>
<li>Lambda</li>
<li>Stream</li>
<li>Optional</li>
<li>Date time-api</li>
</ul>
<p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">阿泽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rongzhiy.github.io/2023/03/17/java/new-features/java8-common-new-features/">https://rongzhiy.github.io/2023/03/17/java/new-features/java8-common-new-features/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rongzhiy.github.io" target="_blank">Rongzhiyのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/08/27/cvFmZnB4jEaNqxg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/17/java/new-features/java8-tutorial-translate/"><img class="prev-cover" src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/tMjlJgx9rymnQ71.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/03/17/java/new-features/java19/"><img class="next-cover" src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/Ck6NOjqPaXSv8Di.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 19 新特性概览</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/images/loading.png" data-original="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">阿泽</div><div class="author-info__description">Stay Hungry,Stay Foolish</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rongzhiy"><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:rongzhiy2735@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2735545128&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/327319339" target="_blank" title="BILiBili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">Java8 新特性实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface"><span class="toc-number">1.1.</span> <span class="toc-text">Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#functional-interface-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">functional interface 函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">Lambda 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">替代匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">集合迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">方法的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">访问变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">1.4.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">流类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.4.</span> <span class="toc-text">延迟执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optional"><span class="toc-number">1.5.</span> <span class="toc-text">Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Optional"><span class="toc-number">1.5.1.</span> <span class="toc-text">如何创建一个 Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">map()相关方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-value-%E6%98%AF%E5%90%A6%E4%B8%BA-null"><span class="toc-number">1.5.3.</span> <span class="toc-text">判断 value 是否为 null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-value"><span class="toc-number">1.5.4.</span> <span class="toc-text">获取 value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%80%BC"><span class="toc-number">1.5.5.</span> <span class="toc-text">过滤值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.5.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-Time-API"><span class="toc-number">1.6.</span> <span class="toc-text">Date-Time API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time-%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-number">1.6.1.</span> <span class="toc-text">java.time 主要类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.6.2.</span> <span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">字符串转日期格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.6.4.</span> <span class="toc-text">日期计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">获取指定日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E5%92%8C-java8"><span class="toc-number">1.6.6.</span> <span class="toc-text">JDBC 和 java8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">1.6.7.</span> <span class="toc-text">时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.6.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告"><img src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/S3Dh8MAcr2yqGW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="李跳跳 安卓跳过广告"/></a><div class="content"><a class="title" href="/2023/08/27/open-source-project/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA/" title="李跳跳 安卓跳过广告">李跳跳 安卓跳过广告</a><time datetime="2023-08-27T11:07:56.206Z" title="发表于 2023-08-27 19:07:56">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南"><img src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/Ck6NOjqPaXSv8Di.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT使用指南"/></a><div class="content"><a class="title" href="/2023/04/26/ChatGPT/ChatGPTGuide/" title="ChatGPT使用指南">ChatGPT使用指南</a><time datetime="2023-04-26T12:00:00.000Z" title="发表于 2023-04-26 20:00:00">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统"><img src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/KFXsIP75dlBOeVN.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="云大千寻 - 基于拍照识别的失物找寻系统"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E4%BA%91%E5%A4%A7%E5%8D%83%E5%AF%BB/" title="云大千寻 - 基于拍照识别的失物找寻系统">云大千寻 - 基于拍照识别的失物找寻系统</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"><img src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/UHmPRBlZsufTKki.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）"/></a><div class="content"><a class="title" href="/2023/04/01/practice/%E5%9F%BA%E4%BA%8ESpringBoot%E7%9A%84%E6%A0%A1%E5%9B%AD%E9%97%AE%E7%AD%94%E7%A4%BE%E5%8C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%89/" title="基于SpringBoot的校园问答社区系统设计与实现（前后端分离）">基于SpringBoot的校园问答社区系统设计与实现（前后端分离）</a><time datetime="2023-04-01T12:00:00.000Z" title="发表于 2023-04-01 20:00:00">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程"><img src="/images/loading.png" data-original="https://s2.loli.net/2023/08/27/S3Dh8MAcr2yqGW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 优质开源技术教程"/></a><div class="content"><a class="title" href="/2023/03/17/open-source-project/tutorial/" title="Java 优质开源技术教程">Java 优质开源技术教程</a><time datetime="2023-03-17T09:00:13.505Z" title="发表于 2023-03-17 17:00:13">2023-03-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 阿泽</div><div class="framework-info"><span>框架 </span><a href="">Hexo</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>